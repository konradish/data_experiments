<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Grid Pathfinding Visualizer</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; height: 100vh; margin: 0; }
        #controls { padding: 10px; background: #eee; border-bottom: 1px solid #ccc; }
        #editor { height: 200px; border: 1px solid #ccc; margin-bottom: 10px; }
        #gridContainer { flex-grow: 1; display: flex; justify-content: center; align-items: center; overflow: auto; }
        canvas { border: 1px solid black; background-color: #f0f0f0; }
        button { margin-right: 5px; padding: 5px 10px; }
    </style>
    <!-- Ace Editor CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.3/ace.js"></script>
    <!-- Pyodide CDN -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.27.5/full/pyodide.js"></script>
</head>
<body>
    <div id="controls">
        <div id="editor">// Default JS BFS example or Python starter
function bfs_custom(grid, start, goal, visit) {
  // Your custom JS algorithm here...
  // Example: Call the imported bfs
  // import { bfs } from './grid_algorithms.js'; // Cannot use import directly here
  // You might need to pass bfs function reference or use a different approach
  console.log("Running custom JS BFS (placeholder)...");
  // For now, just log. Implement actual execution logic.
  const q = [start], seen = new Set([start.toString()]);
  let intervalId = setInterval(() => {
      if (!q.length) {
          clearInterval(intervalId);
          console.log("BFS finished or goal not reachable.");
          return;
      }
      const [x, y] = q.shift();
      visit(x, y, 'visited'); // Mark as visited
      if (x === goal[0] && y === goal[1]) {
          visit(x, y, 'goal'); // Mark goal
          clearInterval(intervalId);
          console.log("Goal reached!");
          return;
      }
      for (const [dx, dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
          const nx = x + dx, ny = y + dy, key = `${nx},${ny}`;
          // Replace optional chaining with standard checks for compatibility
          if (grid[nx] !== undefined && grid[nx][ny] !== undefined && grid[nx][ny] === 1 && !seen.has(key)) { // Check if walkable (1)
              seen.add(key);
              q.push([nx,ny]);
              visit(nx, ny, 'visiting'); // Mark as visiting
          }
      }
  }, 50); // Adjust speed as needed
}
bfs_custom; // Return the function
</div>
        <button id="runJS">Run JS</button>
        <button id="runPython">Run Python</button>
        <button id="resetGrid">Reset Grid</button>
        <select id="editorLang">
            <option value="javascript">JavaScript</option>
            <option value="python">Python</option>
        </select>
         <!-- Add controls for grid size, obstacles, start/goal selection later -->
    </div>
    <div id="gridContainer">
        <canvas id="grid"></canvas>
    </div>

    <script type="module">
        import { bfs, dfs } from './grid_algorithms.js';

        const editor = ace.edit('editor');
        editor.session.setMode('ace/mode/javascript'); // Default mode
        editor.setTheme('ace/theme/monokai');

        const langSelect = document.getElementById('editorLang');
        langSelect.addEventListener('change', (e) => {
            editor.session.setMode(`ace/mode/${e.target.value}`);
            // Optionally load different default code based on language
            if (e.target.value === 'python') {
                editor.setValue(`# Python BFS/DFS Example
import js # Access JavaScript environment

# Pyodide doesn't directly support async/await in top-level script easily for visualization yet.
# We'll use the provided JS functions for now via 'js' module.

def run_python_bfs(grid_proxy, start_proxy, goal_proxy, visit_proxy):
    print("Running Python BFS (via JS call)...")
    # Convert PyProxy objects to Python lists/tuples if needed
    start = start_proxy.to_py()
    goal = goal_proxy.to_py()
    # grid_proxy might need conversion depending on how it's passed

    # Example: Call the JS bfs function passed via Pyodide's global context
    # This requires setting up the JS function in Pyodide's scope beforehand.
    try:
        # Assuming 'js_bfs' is made available to Python
        js.js_bfs(grid_proxy, start_proxy, goal_proxy, visit_proxy)
        print("Python finished calling JS BFS.")
    except Exception as e:
        print(f"Error calling JS BFS from Python: {e}")

# Make the function available to JS
run_python_bfs
`);
            } else {
                 editor.setValue(`// Default JS BFS example or Python starter
function bfs_custom(grid, start, goal, visit) {
  // Your custom JS algorithm here...
  console.log("Running custom JS BFS...");
  const q = [start], seen = new Set([start.toString()]);
  let intervalId = setInterval(() => {
      if (!q.length) {
          clearInterval(intervalId);
          console.log("BFS finished or goal not reachable.");
          return;
      }
      const [x, y] = q.shift();
      if (grid[x][y] === 3) return; // Skip obstacles
      visit(x, y, 'visited'); // Mark as visited
      if (x === goal[0] && y === goal[1]) {
          visit(x, y, 'goal'); // Mark goal
          clearInterval(intervalId);
          console.log("Goal reached!");
          return;
      }
      for (const [dx, dy] of [[1,0],[-1,0],[0,1],[0,-1]]) {
          const nx = x + dx, ny = y + dy, key = \`\${nx},\${ny}\`;
          // Check bounds and if walkable (1) or start/goal (which might be overwritten)
          if (grid[nx] !== undefined && grid[nx][ny] !== undefined && grid[nx][ny] !== 3 && !seen.has(key)) {
              seen.add(key);
              q.push([nx,ny]);
              if (grid[nx][ny] !== 2) { // Don't mark start/goal as 'visiting'
                 visit(nx, ny, 'visiting'); // Mark as visiting
              }
          }
      }
  }, 50); // Adjust speed as needed
}
bfs_custom; // Return the function`);
            }
            editor.clearSelection();
        });


        // Grid setup
        const ROWS = 30, COLS = 40, SIZE = 18;
        const cvs = document.getElementById('grid');
        const ctx = cvs.getContext('2d');
        cvs.width = COLS * SIZE;
        cvs.height = ROWS * SIZE;

        // Grid state: 0=Empty(unused), 1=Walkable, 2=Start/Goal, 3=Obstacle, 4=Visited, 5=Visiting, 6=Path
        let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(1));
        let start = [1, 1]; // Default start
        let goal = [ROWS - 2, COLS - 2]; // Default goal
        let pyodide = null;
        let pyodideLoading = false;
        let currentAlgorithmInterval = null; // To stop ongoing animations

        function initializeGrid() {
            grid = Array.from({ length: ROWS }, () => Array(COLS).fill(1));
            // Place start and goal
            if (grid[start[0]] && grid[start[0]][start[1]] !== undefined) grid[start[0]][start[1]] = 2;
            if (grid[goal[0]] && grid[goal[0]][goal[1]] !== undefined) grid[goal[0]][goal[1]] = 2;
            drawGrid();
        }

        function drawGrid() {
            ctx.clearRect(0, 0, cvs.width, cvs.height);
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    ctx.fillStyle = getColor(grid[r][c]);
                    ctx.fillRect(c * SIZE, r * SIZE, SIZE, SIZE);
                    ctx.strokeStyle = '#ccc'; // Grid lines
                    ctx.strokeRect(c * SIZE, r * SIZE, SIZE, SIZE);
                }
            }
        }

        function getColor(cellType) {
            switch (cellType) {
                case 1: return '#fff'; // Walkable
                case 2: return 'green'; // Start/Goal
                case 3: return '#555'; // Obstacle
                case 4: return 'lightblue'; // Visited
                case 5: return 'yellow'; // Visiting (in queue)
                case 6: return 'blue'; // Path
                default: return '#eee'; // Default/Empty
            }
        }

        // Visualization callback for algorithms
        function visitCell(r, c, type = 'visited') {
             if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return; // Bounds check
             const currentVal = grid[r][c];
             // Don't overwrite start/goal/obstacles unless marking as path
             if (currentVal === 2 || currentVal === 3) {
                 if (type !== 'path') return;
             }

             switch (type) {
                 case 'visited': grid[r][c] = 4; break;
                 case 'visiting': grid[r][c] = 5; break;
                 case 'path': grid[r][c] = 6; break;
                 case 'goal': grid[r][c] = 2; break; // Ensure goal stays green
                 default: grid[r][c] = 4; // Default to visited
             }
             // Immediate redraw for visualization
             // Debounce or requestAnimationFrame might be better for performance
             drawGrid();
        }

        // Stop any running algorithm animation
        function stopCurrentAlgorithm() {
            if (currentAlgorithmInterval) {
                clearInterval(currentAlgorithmInterval);
                currentAlgorithmInterval = null;
            }
            // Reset 'visiting' cells back to 'walkable' or 'visited' if needed
             for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (grid[r][c] === 5) grid[r][c] = 4; // Turn visiting yellow back to visited blue
                }
            }
            drawGrid();
        }


        // --- Pyodide Setup ---
        async function loadPyodideInstance() {
            if (!pyodide && !pyodideLoading) {
                console.log("Loading Pyodide...");
                pyodideLoading = true;
                try {
                    pyodide = await loadPyodide();
                    console.log("Pyodide loaded.");
                    // Make JS functions available to Python
                    pyodide.globals.set('js_bfs', bfs); // Example: provide imported bfs
                    pyodide.globals.set('js_dfs', dfs);
                    pyodide.globals.set('js_visit', visitCell);
                } catch (error) {
                    console.error("Pyodide loading failed:", error);
                    pyodide = null; // Reset on failure
                } finally {
                    pyodideLoading = false;
                }
            }
            return pyodide;
        }

        // --- Event Listeners ---
        document.getElementById('runJS').onclick = () => {
            stopCurrentAlgorithm();
            initializeGrid(); // Reset grid state but keep obstacles
            try {
                // Use Function constructor to evaluate editor code safely in a limited scope
                // Note: This still has security implications if the code is untrusted.
                // For a safer approach, consider web workers or sandboxing libraries.
                const userCode = editor.getValue();
                // Escape any back-ticks that occur inside the editor code so the Function
                // constructor doesn’t break.
                const safeUserCode = userCode.replace(/`/g, '\\`');
                const funcSrc =  safeUserCode +
                                '\nreturn (typeof bfs_custom === "function") ? bfs_custom : null;';
                const algoFn = new Function('grid', 'start', 'goal', 'visit', funcSrc)();   // immediately invoked

                if (typeof algoFn === 'function') {
                     // Run the user's function - it should handle its own timing/async
                     algoFn(grid, start, goal, visitCell);
                } else {
                     console.error("Editor code did not define a runnable function (e.g., bfs_custom).");
                     alert("Could not find a function to run in the JS editor.");
                }
            } catch (error) {
                console.error("Error executing JS code:", error);
                alert(`Error in JS code: ${error.message}`);
            }
        };

        document.getElementById('runPython').onclick = async () => {
            stopCurrentAlgorithm();
            initializeGrid();
            const py = await loadPyodideInstance();
            if (!py) {
                alert("Pyodide failed to load. Cannot run Python code.");
                return;
            }
            console.log("Running Python code...");
            try {
                const pythonCode = editor.getValue();
                // Make grid, start, goal, visit available to Python
                // Use pyodide.toPy to convert JS objects if necessary
                py.globals.set('py_grid', pyodide.toPy(grid));
                py.globals.set('py_start', pyodide.toPy(start));
                py.globals.set('py_goal', pyodide.toPy(goal));
                // js_visit is already set globally during load

                // Execute the Python code. Assume it defines and calls a function like run_python_bfs
                await py.runPythonAsync(`
import js # Make sure js module is available
from pyodide.ffi import to_py # For converting PyProxy if needed

# Get JS variables from global scope
grid_proxy = js.py_grid
start_proxy = js.py_start
goal_proxy = js.py_goal
visit_callback = js.js_visit # The JS visitCell function

${pythonCode}

# Attempt to call the function defined in the editor
try:
    # Assuming the user code defines a function, e.g., run_python_bfs
    # We need to call it explicitly here.
    if 'run_python_bfs' in globals():
        run_python_bfs(grid_proxy, start_proxy, goal_proxy, visit_callback)
    elif 'run_python_dfs' in globals():
         run_python_dfs(grid_proxy, start_proxy, goal_proxy, visit_callback) # Example for DFS
    else:
        print("No function like 'run_python_bfs' found in Python code.")

except Exception as e:
    print(f"Error executing Python function: {e}")

`);
                console.log("Python code execution finished.");
                // Update grid from Python? If Python modifies py_grid, we might need to sync back
                // grid = py.globals.get('py_grid').toJs(); // Example sync back
                // drawGrid();
            } catch (error) {
                console.error("Error executing Python code:", error);
                alert(`Error in Python code: ${error}`);
            }
        };

        document.getElementById('resetGrid').onclick = () => {
             stopCurrentAlgorithm();
             initializeGrid();
        };

        // Add basic obstacle drawing on click
        cvs.addEventListener('click', (e) => {
            if (currentAlgorithmInterval) return; // Don't modify while an algorithm is running

            const rect = cvs.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const col = Math.floor(x / SIZE);
            const row = Math.floor(y / SIZE);

            if (row >= 0 && row < ROWS && col >= 0 && col < COLS) {
                // Toggle obstacle (avoid start/goal)
                if (grid[row][col] !== 2) {
                    grid[row][col] = (grid[row][col] === 3) ? 1 : 3; // Toggle between walkable and obstacle
                    drawGrid();
                }
            }
        });


        // Initial setup
        initializeGrid();
        loadPyodideInstance(); // Start loading Pyodide in the background

    </script>
</body>
</html>
