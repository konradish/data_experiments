<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Grid Pathfinding Visualizer</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        #controls { /* Basic controls panel styling - copy/adapt from 3d_sorting_visualizer.html */
            position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; z-index: 100;
        }
        /* Add other styles as needed */
    </style>
</head>
<body>
    <!-- Add Controls Panel HTML structure here (similar to 3d_sorting_visualizer.html) -->
    <div id="controls">
         <h3>3D Grid Controls</h3>
         <button id="runBFS_3D">Run BFS</button>
         <button id="resetGrid_3D">Reset Grid</button>
         <!-- Add more controls later -->
    </div>

    <!-- Three.js core library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Post Processing Libraries (Example CDNs - verify versions) -->
    <!-- You MUST include these or equivalent for BloomEffect to work -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectPass.js"></script> <!-- Might be needed depending on exact Bloom implementation -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script> <!-- Common bloom pass -->
    <!-- Note: The exact postprocessing setup might vary. The user diff mentioned POSTPROCESSING.BloomEffect which might map to UnrealBloomPass or another implementation. -->


    <script type="module">
        // Import algorithms
        import { bfs, dfs } from './grid_algorithms.js';

        // Basic Three.js Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 40, 50); // Adjusted initial position

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Orbit Controls (Ensure THREE.OrbitControls is loaded)
        let controls;
        if (typeof THREE.OrbitControls === 'function') {
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.target.set(0, 0, 0); // Look at grid center
        } else {
            console.error("THREE.OrbitControls not loaded!");
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Grid Helper
        const GRID_SIZE = 40; // World units
        const GRID_DIVISIONS = 40; // Number of cells
        const CELL_SIZE = GRID_SIZE / GRID_DIVISIONS;
        // Use brighter colors for the grid lines
        const gridHelper = new THREE.GridHelper(GRID_SIZE, GRID_DIVISIONS, 0x00ff00, 0x888888); // Bright Green and Light Grey
        gridHelper.position.y = 0; // Position at origin
        scene.add(gridHelper);

        // Grid state (logical) - Adapt dimensions as needed
        const ROWS = GRID_DIVISIONS;
        const COLS = GRID_DIVISIONS;
        let logicalGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(1)); // 1=Walkable, 3=Obstacle
        let start = [Math.floor(ROWS/4), Math.floor(COLS/4)];
        let goal = [Math.floor(ROWS*3/4), Math.floor(COLS*3/4)];

        // Visualization objects group
        const vizGroup = new THREE.Group();
        scene.add(vizGroup);

        // Post Processing (Bloom Effect) - Requires EffectComposer, RenderPass, UnrealBloomPass
        let composer;
        if (typeof THREE.EffectComposer === 'function' &&
            typeof THREE.RenderPass === 'function' &&
            typeof THREE.UnrealBloomPass === 'function')
        {
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.2, // intensity (strength)
                0.4, // radius
                0.85 // threshold
            );
            composer.addPass(bloomPass);
             console.log("Bloom effect added.");
        } else {
            console.error("Required PostProcessing components (EffectComposer, RenderPass, UnrealBloomPass) not loaded!");
            composer = null; // Fallback to direct rendering
        }


        // --- Grid Logic & Visualization ---

        function worldToGrid(worldX, worldZ) {
            const gridX = Math.floor((worldX + GRID_SIZE / 2) / CELL_SIZE);
            const gridZ = Math.floor((worldZ + GRID_SIZE / 2) / CELL_SIZE);
            return [gridZ, gridX]; // Map Z to Row, X to Col
        }

        function gridToWorld(r, c) {
            const worldX = (c + 0.5) * CELL_SIZE - GRID_SIZE / 2;
            const worldZ = (r + 0.5) * CELL_SIZE - GRID_SIZE / 2;
            return [worldX, worldZ];
        }

        function initializeLogicalGrid() {
            logicalGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(1));
            // Add some obstacles or allow user interaction later
            // logicalGrid[5][5] = 3;
            // logicalGrid[5][6] = 3;
            // logicalGrid[5][7] = 3;
            resetVisualization();
        }

        function resetVisualization() {
             // Clear previous visualization objects
            while(vizGroup.children.length > 0){
                const obj = vizGroup.children[0];
                vizGroup.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                     if (Array.isArray(obj.material)) {
                         obj.material.forEach(m => m.dispose());
                     } else {
                         obj.material.dispose();
                     }
                }
            }
            // Add start and goal markers
            addMarker(start[0], start[1], 0x00ff00); // Green for start
            addMarker(goal[0], goal[1], 0xff0000);   // Red for goal
        }

        function addMarker(r, c, color, size = CELL_SIZE * 0.8, height = 0.5) {
            const [worldX, worldZ] = gridToWorld(r, c);
            const geometry = new THREE.BoxGeometry(size, height, size);
            // Use MeshStandardMaterial for lighting, MeshBasicMaterial for simple color/glow
            const material = new THREE.MeshStandardMaterial({
                 color: color,
                 emissive: color, // Make it glow slightly
                 emissiveIntensity: 0.5,
                 metalness: 0.2,
                 roughness: 0.8
            });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.set(worldX, height / 2, worldZ);
            marker.userData = { type: 'marker', gridR: r, gridC: c };
            vizGroup.add(marker);
            return marker;
        }

        // Visualization callback for algorithms
        function visitCell3D(r, c, type = 'visited') {
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return;
            if (logicalGrid[r][c] === 3) return; // Skip obstacles

            let color = 0x0000ff; // Default blue for visited
            let size = CELL_SIZE * 0.5;
            let height = 0.2;

            switch(type) {
                case 'visiting':
                    color = 0xffff00; // Yellow
                    size = CELL_SIZE * 0.4;
                    break;
                case 'path':
                    color = 0x00ffff; // Cyan
                    size = CELL_SIZE * 0.6;
                    height = 0.3;
                    break;
                case 'visited':
                default:
                    color = 0x0000ff; // Blue
                    break;
            }

            // Avoid drawing over start/goal unless it's the path
            if ((r === start[0] && c === start[1]) || (r === goal[0] && c === goal[1])) {
                 if (type !== 'path') return;
            }

            addMarker(r, c, color, size, height);
        }

        // --- Algorithm Execution ---
        let isAnimating3D = false;
        let animationQueue = [];
        let animationInterval = null;

        function runBFS_3D() {
            if (isAnimating3D) return;
            resetVisualization(); // Clear previous run
            isAnimating3D = true;
            animationQueue = []; // Reset queue

            // Wrap the original BFS to push steps onto the queue instead of direct calls
            const visitWrapper = (r, c, type) => {
                animationQueue.push({ r, c, type });
            };

            console.log("Starting 3D BFS calculation...");
            const found = bfs(logicalGrid, start, goal, visitWrapper); // Run BFS, collecting steps
            console.log(`BFS calculation finished. Found: ${found}. Steps: ${animationQueue.length}`);

            // Start processing the animation queue
            processAnimationQueue();
        }

        function processAnimationQueue() {
            const stepsPerFrame = 5; // Adjust speed
            animationInterval = setInterval(() => {
                if (animationQueue.length === 0) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                    isAnimating3D = false;
                    console.log("3D BFS animation finished.");
                    return;
                }

                const stepsToProcess = Math.min(stepsPerFrame, animationQueue.length);
                for (let i = 0; i < stepsToProcess; i++) {
                    const step = animationQueue.shift();
                    visitCell3D(step.r, step.c, step.type);
                }
            }, 50); // Interval time (ms)
        }

        function stopAnimation() {
             if (animationInterval) {
                 clearInterval(animationInterval);
                 animationInterval = null;
             }
             isAnimating3D = false;
             animationQueue = []; // Clear remaining steps
        }


        // --- Event Listeners ---
        document.getElementById('runBFS_3D').addEventListener('click', runBFS_3D);
        document.getElementById('resetGrid_3D').addEventListener('click', () => {
             stopAnimation();
             initializeLogicalGrid();
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                 composer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update(); // Required if enableDamping is true

            // Use composer if available, otherwise direct render
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // Initial setup
        initializeLogicalGrid();
        animate();

    </script>
</body>
</html>
