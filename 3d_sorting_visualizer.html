<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Sorting Algorithm Visualization for ML Pattern Analysis</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        select, button {
            margin: 5px 0;
            padding: 5px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>Sorting Algorithm Visualization</h2>
        <p>This visualization shows sorting algorithms in 3D space, with time as the third dimension.</p>
        <p>Features:</p>
        <ul>
            <li>Element positions shown as colored bars</li>
            <li>Comparisons visualized as connecting lines</li>
            <li>Movement tracking with color fading</li>
            <li>3D time progression to observe patterns</li>
        </ul>
        <p>Rotate: Left-click + drag</p>
        <p>Zoom: Scroll wheel</p>
        <p>Pan: Right-click + drag</p>
    </div>
    <div id="controls">
        <h3>Controls</h3>
        <select id="algorithm">
            <option value="bubble">Bubble Sort</option>
            <option value="insertion">Insertion Sort</option>
            <option value="selection">Selection Sort</option>
            <option value="quick">Quick Sort</option>
            <option value="merge">Merge Sort</option>
        </select>
        <select id="dataSize">
            <option value="20">20 Elements</option>
            <option value="50">50 Elements</option>
            <option value="100">100 Elements</option>
        </select>
        <select id="dataPattern">
            <option value="random">Random</option>
            <option value="nearlySorted">Nearly Sorted</option>
            <option value="reversed">Reversed</option>
        </select>
        <button id="startBtn">Start Sorting</button>
        <button id="resetBtn">Reset</button>
        <div>
            <label><input type="checkbox" id="showComparisons" checked> Show Comparisons</label>
        </div>
        <div>
            <label><input type="checkbox" id="showMovement" checked> Track Movement</label>
        </div>
        <div>
            <label>Animation Speed: <input type="range" id="speed" min="1" max="10" value="5"></label>
        </div>
    </div>

    <!-- Import Three.js library and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat.gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/16/Stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    
    <!-- Import OrbitControls from Three.js examples -->
    <script>
        // OrbitControls implementation from Three.js examples
        // https://github.com/mrdoob/three.js/blob/master/examples/js/controls/OrbitControls.js
        THREE.OrbitControls = function ( object, domElement ) {

            this.object = object;
            this.domElement = ( domElement !== undefined ) ? domElement : document;

            // Set to false to disable this control
            this.enabled = true;

            // "target" sets the location of focus, where the object orbits around
            this.target = new THREE.Vector3();

            // How far you can dolly in and out ( PerspectiveCamera only )
            this.minDistance = 0;
            this.maxDistance = Infinity;

            // How far you can zoom in and out ( OrthographicCamera only )
            this.minZoom = 0;
            this.maxZoom = Infinity;

            // How far you can orbit vertically, upper and lower limits.
            // Range is 0 to Math.PI radians.
            this.minPolarAngle = 0; // radians
            this.maxPolarAngle = Math.PI; // radians

            // How far you can orbit horizontally, upper and lower limits.
            // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
            this.minAzimuthAngle = - Infinity; // radians
            this.maxAzimuthAngle = Infinity; // radians

            // Set to true to enable damping (inertia)
            // If damping is enabled, you must call controls.update() in your animation loop
            this.enableDamping = false;
            this.dampingFactor = 0.25;

            // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
            // Set to false to disable zooming
            this.enableZoom = true;
            this.zoomSpeed = 1.0;

            // Set to false to disable rotating
            this.enableRotate = true;
            this.rotateSpeed = 1.0;

            // Set to false to disable panning
            this.enablePan = true;
            this.panSpeed = 1.0;
            this.screenSpacePanning = false; // if true, pan in screen-space
            this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

            // Set to true to automatically rotate around the target
            // If auto-rotate is enabled, you must call controls.update() in your animation loop
            this.autoRotate = false;
            this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

            // Set to false to disable use of the keys
            this.enableKeys = true;

            // The four arrow keys
            this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

            // Mouse buttons
            this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT };

            // for reset
            this.target0 = this.target.clone();
            this.position0 = this.object.position.clone();
            this.zoom0 = this.object.zoom;

            //
            // public methods
            //

            this.getPolarAngle = function () {
                return spherical.phi;
            };

            this.getAzimuthalAngle = function () {
                return spherical.theta;
            };

            this.saveState = function () {
                scope.target0.copy( scope.target );
                scope.position0.copy( scope.object.position );
                scope.zoom0 = scope.object.zoom;
            };

            this.reset = function () {
                scope.target.copy( scope.target0 );
                scope.object.position.copy( scope.position0 );
                scope.object.zoom = scope.zoom0;

                scope.object.updateProjectionMatrix();
                scope.dispatchEvent( changeEvent );

                scope.update();

                state = STATE.NONE;
            };

            // this method is exposed, but perhaps it would be better if we can make it private...
            this.update = function () {

                var offset = new THREE.Vector3();

                // so camera.up is the orbit axis
                var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
                var quatInverse = quat.clone().inverse();

                var lastPosition = new THREE.Vector3();
                var lastQuaternion = new THREE.Quaternion();

                return function update() {

                    var position = scope.object.position;

                    offset.copy( position ).sub( scope.target );

                    // rotate offset to "y-axis-is-up" space
                    offset.applyQuaternion( quat );

                    // angle from z-axis around y-axis
                    spherical.setFromVector3( offset );

                    if ( scope.autoRotate && state === STATE.NONE ) {
                        rotateLeft( getAutoRotationAngle() );
                    }

                    spherical.theta += sphericalDelta.theta;
                    spherical.phi += sphericalDelta.phi;

                    // restrict theta to be between desired limits
                    spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

                    // restrict phi to be between desired limits
                    spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

                    spherical.makeSafe();

                    spherical.radius *= scale;

                    // restrict radius to be between desired limits
                    spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

                    // move target to panned location
                    scope.target.add( panOffset );

                    offset.setFromSpherical( spherical );

                    // rotate offset back to "camera-up-vector-is-up" space
                    offset.applyQuaternion( quatInverse );

                    position.copy( scope.target ).add( offset );

                    scope.object.lookAt( scope.target );

                    if ( scope.enableDamping === true ) {
                        sphericalDelta.theta *= ( 1 - scope.dampingFactor );
                        sphericalDelta.phi *= ( 1 - scope.dampingFactor );
                        panOffset.multiplyScalar( 1 - scope.dampingFactor );
                    } else {
                        sphericalDelta.set( 0, 0, 0 );
                        panOffset.set( 0, 0, 0 );
                    }

                    scale = 1;

                    // update condition is:
                    // min(camera displacement, camera rotation in radians)^2 > EPS
                    // using small-angle approximation cos(x/2) = 1 - x^2 / 8

                    if ( zoomChanged ||
                        lastPosition.distanceToSquared( scope.object.position ) > EPS ||
                        8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

                        scope.dispatchEvent( changeEvent );

                        lastPosition.copy( scope.object.position );
                        lastQuaternion.copy( scope.object.quaternion );
                        zoomChanged = false;

                        return true;
                    }

                    return false;
                };
            }();

            this.dispose = function () {
                scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
                scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
                scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

                scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
                scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
                scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

                document.removeEventListener( 'mousemove', onMouseMove, false );
                document.removeEventListener( 'mouseup', onMouseUp, false );

                window.removeEventListener( 'keydown', onKeyDown, false );
            };

            //
            // internals
            //

            var scope = this;

            var changeEvent = { type: 'change' };
            var startEvent = { type: 'start' };
            var endEvent = { type: 'end' };

            var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };

            var state = STATE.NONE;

            var EPS = 0.000001;

            // current position in spherical coordinates
            var spherical = new THREE.Spherical();
            var sphericalDelta = new THREE.Spherical();

            var scale = 1;
            var panOffset = new THREE.Vector3();
            var zoomChanged = false;

            var rotateStart = new THREE.Vector2();
            var rotateEnd = new THREE.Vector2();
            var rotateDelta = new THREE.Vector2();

            var panStart = new THREE.Vector2();
            var panEnd = new THREE.Vector2();
            var panDelta = new THREE.Vector2();

            var dollyStart = new THREE.Vector2();
            var dollyEnd = new THREE.Vector2();
            var dollyDelta = new THREE.Vector2();

            function getAutoRotationAngle() {
                return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
            }

            function getZoomScale() {
                return Math.pow( 0.95, scope.zoomSpeed );
            }

            function rotateLeft( angle ) {
                sphericalDelta.theta -= angle;
            }

            function rotateUp( angle ) {
                sphericalDelta.phi -= angle;
            }

            var panLeft = function () {
                var v = new THREE.Vector3();

                return function panLeft( distance, objectMatrix ) {
                    v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
                    v.multiplyScalar( - distance );
                    panOffset.add( v );
                };
            }();

            var panUp = function () {
                var v = new THREE.Vector3();

                return function panUp( distance, objectMatrix ) {
                    if ( scope.screenSpacePanning === true ) {
                        v.setFromMatrixColumn( objectMatrix, 1 );
                    } else {
                        v.setFromMatrixColumn( objectMatrix, 0 );
                        v.crossVectors( scope.object.up, v );
                    }
                    v.multiplyScalar( distance );
                    panOffset.add( v );
                };
            }();

            // deltaX and deltaY are in pixels; right and down are positive
            var pan = function () {
                var offset = new THREE.Vector3();

                return function pan( deltaX, deltaY ) {
                    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                    if ( scope.object.isPerspectiveCamera ) {
                        // perspective
                        var position = scope.object.position;
                        offset.copy( position ).sub( scope.target );
                        var targetDistance = offset.length();

                        // half of the fov is center to top of screen
                        targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

                        // we use only clientHeight here so aspect ratio does not distort speed
                        panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
                        panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );
                    } else if ( scope.object.isOrthographicCamera ) {
                        // orthographic
                        panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
                        panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );
                    } else {
                        // camera neither orthographic nor perspective
                        console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
                        scope.enablePan = false;
                    }
                };
            }();

            function dollyIn( dollyScale ) {
                if ( scope.object.isPerspectiveCamera ) {
                    scale /= dollyScale;
                } else if ( scope.object.isOrthographicCamera ) {
                    scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
                    scope.object.updateProjectionMatrix();
                    zoomChanged = true;
                } else {
                    console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                    scope.enableZoom = false;
                }
            }

            function dollyOut( dollyScale ) {
                if ( scope.object.isPerspectiveCamera ) {
                    scale *= dollyScale;
                } else if ( scope.object.isOrthographicCamera ) {
                    scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
                    scope.object.updateProjectionMatrix();
                    zoomChanged = true;
                } else {
                    console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                    scope.enableZoom = false;
                }
            }

            //
            // event callbacks - update the object state
            //

            function handleMouseDownRotate( event ) {
                rotateStart.set( event.clientX, event.clientY );
            }

            function handleMouseDownDolly( event ) {
                dollyStart.set( event.clientX, event.clientY );
            }

            function handleMouseDownPan( event ) {
                panStart.set( event.clientX, event.clientY );
            }

            function handleMouseMoveRotate( event ) {
                rotateEnd.set( event.clientX, event.clientY );
                rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height
                rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

                rotateStart.copy( rotateEnd );

                scope.update();
            }

            function handleMouseMoveDolly( event ) {
                dollyEnd.set( event.clientX, event.clientY );
                dollyDelta.subVectors( dollyEnd, dollyStart );

                if ( dollyDelta.y > 0 ) {
                    dollyIn( getZoomScale() );
                } else if ( dollyDelta.y < 0 ) {
                    dollyOut( getZoomScale() );
                }

                dollyStart.copy( dollyEnd );
                scope.update();
            }

            function handleMouseMovePan( event ) {
                panEnd.set( event.clientX, event.clientY );
                panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

                pan( panDelta.x, panDelta.y );

                panStart.copy( panEnd );
                scope.update();
            }

            function handleMouseUp( /*event*/ ) {
                // no-op
            }

            function handleMouseWheel( event ) {
                if ( event.deltaY < 0 ) {
                    dollyOut( getZoomScale() );
                } else if ( event.deltaY > 0 ) {
                    dollyIn( getZoomScale() );
                }

                scope.update();
            }

            function handleKeyDown( event ) {
                var needsUpdate = false;

                switch ( event.keyCode ) {
                    case scope.keys.UP:
                        pan( 0, scope.keyPanSpeed );
                        needsUpdate = true;
                        break;

                    case scope.keys.BOTTOM:
                        pan( 0, - scope.keyPanSpeed );
                        needsUpdate = true;
                        break;

                    case scope.keys.LEFT:
                        pan( scope.keyPanSpeed, 0 );
                        needsUpdate = true;
                        break;

                    case scope.keys.RIGHT:
                        pan( - scope.keyPanSpeed, 0 );
                        needsUpdate = true;
                        break;
                }

                if ( needsUpdate ) {
                    // prevent the browser from scrolling on cursor keys
                    event.preventDefault();
                    scope.update();
                }
            }

            function handleTouchStartRotate( event ) {
                if ( event.touches.length == 1 ) {
                    rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                } else {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

                    rotateStart.set( x, y );
                }
            }

            function handleTouchStartDollyPan( event ) {
                if ( scope.enableZoom ) {
                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

                    var distance = Math.sqrt( dx * dx + dy * dy );

                    dollyStart.set( 0, distance );
                }

                if ( scope.enablePan ) {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

                    panStart.set( x, y );
                }
            }

            function handleTouchMoveRotate( event ) {
                if ( event.touches.length == 1 ) {
                    rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                } else {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

                    rotateEnd.set( x, y );
                }

                rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height
                rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

                rotateStart.copy( rotateEnd );
            }

            function handleTouchMoveDollyPan( event ) {
                if ( scope.enableZoom ) {
                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

                    var distance = Math.sqrt( dx * dx + dy * dy );

                    dollyEnd.set( 0, distance );
                    dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

                    dollyIn( dollyDelta.y );
                    dollyStart.copy( dollyEnd );
                }

                if ( scope.enablePan ) {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

                    panEnd.set( x, y );
                    panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

                    pan( panDelta.x, panDelta.y );
                    panStart.copy( panEnd );
                }

                scope.update();
            }

            function handleTouchEnd( /*event*/ ) {
                // no-op
            }

            //
            // event handlers - FSM: listen for events and reset state
            //

            function onMouseDown( event ) {
                if ( scope.enabled === false ) return;

                // Prevent the browser from scrolling.
                event.preventDefault();

                // Manually set the focus since calling preventDefault above
                // prevents the browser from setting it automatically.

                scope.domElement.focus ? scope.domElement.focus() : window.focus();

                switch ( event.button ) {
                    case scope.mouseButtons.LEFT:
                        if ( event.ctrlKey || event.metaKey || event.shiftKey ) {
                            if ( scope.enablePan === false ) return;
                            handleMouseDownPan( event );
                            state = STATE.PAN;
                        } else {
                            if ( scope.enableRotate === false ) return;
                            handleMouseDownRotate( event );
                            state = STATE.ROTATE;
                        }
                        break;

                    case scope.mouseButtons.MIDDLE:
                        if ( scope.enableZoom === false ) return;
                        handleMouseDownDolly( event );
                        state = STATE.DOLLY;
                        break;

                    case scope.mouseButtons.RIGHT:
                        if ( scope.enablePan === false ) return;
                        handleMouseDownPan( event );
                        state = STATE.PAN;
                        break;
                }

                if ( state !== STATE.NONE ) {
                    document.addEventListener( 'mousemove', onMouseMove, false );
                    document.addEventListener( 'mouseup', onMouseUp, false );
                    scope.dispatchEvent( startEvent );
                }
            }

            function onMouseMove( event ) {
                if ( scope.enabled === false ) return;

                event.preventDefault();

                switch ( state ) {
                    case STATE.ROTATE:
                        if ( scope.enableRotate === false ) return;
                        handleMouseMoveRotate( event );
                        break;

                    case STATE.DOLLY:
                        if ( scope.enableZoom === false ) return;
                        handleMouseMoveDolly( event );
                        break;

                    case STATE.PAN:
                        if ( scope.enablePan === false ) return;
                        handleMouseMovePan( event );
                        break;
                }
            }

            function onMouseUp( event ) {
                if ( scope.enabled === false ) return;

                handleMouseUp( event );

                document.removeEventListener( 'mousemove', onMouseMove, false );
                document.removeEventListener( 'mouseup', onMouseUp, false );

                scope.dispatchEvent( endEvent );

                state = STATE.NONE;
            }

            function onMouseWheel( event ) {
                if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

                event.preventDefault();
                event.stopPropagation();

                scope.dispatchEvent( startEvent );
                handleMouseWheel( event );
                scope.dispatchEvent( endEvent );
            }

            function onKeyDown( event ) {
                if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;
                handleKeyDown( event );
            }

            function onTouchStart( event ) {
                if ( scope.enabled === false ) return;

                event.preventDefault();

                switch ( event.touches.length ) {
                    case 1:	// one-fingered touch: rotate
                        if ( scope.enableRotate === false ) return;
                        handleTouchStartRotate( event );
                        state = STATE.TOUCH_ROTATE;
                        break;

                    case 2:	// two-fingered touch: dolly-pan
                        if ( scope.enableZoom === false && scope.enablePan === false ) return;
                        handleTouchStartDollyPan( event );
                        state = STATE.TOUCH_DOLLY_PAN;
                        break;

                    default:
                        state = STATE.NONE;
                }

                if ( state !== STATE.NONE ) {
                    scope.dispatchEvent( startEvent );
                }
            }

            function onTouchMove( event ) {
                if ( scope.enabled === false ) return;

                event.preventDefault();
                event.stopPropagation();

                switch ( event.touches.length ) {
                    case 1: // one-fingered touch: rotate
                        if ( scope.enableRotate === false ) return;
                        if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?
                        handleTouchMoveRotate( event );
                        break;

                    case 2: // two-fingered touch: dolly-pan
                        if ( scope.enableZoom === false && scope.enablePan === false ) return;
                        if ( state !== STATE.TOUCH_DOLLY_PAN ) return; // is this needed?
                        handleTouchMoveDollyPan( event );
                        break;

                    default:
                        state = STATE.NONE;
                }
            }

            function onTouchEnd( event ) {
                if ( scope.enabled === false ) return;

                handleTouchEnd( event );
                scope.dispatchEvent( endEvent );
                state = STATE.NONE;
            }

            function onContextMenu( event ) {
                if ( scope.enabled === false ) return;
                event.preventDefault();
            }

            //

            scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );
            scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
            scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

            scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
            scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
            scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

            window.addEventListener( 'keydown', onKeyDown, false );

            // force an update at start
            this.update();
        };

        THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
        THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
    </script>

    <script>
        // Main application
        const app = {
            scene: null,
            camera: null,
            renderer: null,
            controls: null,
            arrays: [],
            comparisons: [],
            movements: [],
            currentStep: 0,
            isAnimating: false,
            animationSpeed: 5,
            showComparisons: true,
            showMovement: true,
            dataSize: 20,
            algorithm: 'bubble',
            dataPattern: 'random',
            algorithmSteps: [],
            comparisonLines: [],
            movementTrails: [],
            stats: null,
            
            init() {
                // Create Three.js scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x111122);
                
                // Camera setup - more overhead angle
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(30, 120, 30);
                this.camera.lookAt(0, 0, 0);
                
                // Camera animation properties
                this.cameraTarget = {
                    position: new THREE.Vector3(30, 120, 30),
                    lookAt: new THREE.Vector3(0, 0, 0)
                };
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);
                
                // Orbit controls with reduced sensitivity
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.25;
                this.controls.rotateSpeed = 0.5;  // Reduce rotation speed
                this.controls.zoomSpeed = 0.6;    // Reduce zoom speed
                this.controls.panSpeed = 0.5;     // Reduce pan speed
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);
                
                // Add grid with extended size
                const gridHelper = new THREE.GridHelper(400, 40, 0x555555, 0x333333);
                this.scene.add(gridHelper);
                
                // Add x, y, z axes
                const axesHelper = new THREE.AxesHelper(50);
                this.scene.add(axesHelper);
                
                // Stats
                this.stats = new Stats();
                this.stats.showPanel(0);
                document.body.appendChild(this.stats.dom);
                
                // Initialize event listeners
                this.initEventListeners();
                
                // Generate initial data
                this.generateData();
                
                // Start animation loop
                this.animate();
            },
            
            initEventListeners() {
                document.getElementById('algorithm').addEventListener('change', (e) => {
                    this.algorithm = e.target.value;
                });
                
                document.getElementById('dataSize').addEventListener('change', (e) => {
                    this.dataSize = parseInt(e.target.value);
                    this.reset();
                });
                
                document.getElementById('dataPattern').addEventListener('change', (e) => {
                    this.dataPattern = e.target.value;
                    this.reset();
                });
                
                document.getElementById('startBtn').addEventListener('click', () => {
                    if (!this.isAnimating) {
                        this.runSortingAlgorithm();
                        this.isAnimating = true;
                    }
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });
                
                document.getElementById('showComparisons').addEventListener('change', (e) => {
                    this.showComparisons = e.target.checked;
                    this.updateVisualization();
                });
                
                document.getElementById('showMovement').addEventListener('change', (e) => {
                    this.showMovement = e.target.checked;
                    this.updateVisualization();
                });
                
                document.getElementById('speed').addEventListener('input', (e) => {
                    this.animationSpeed = parseInt(e.target.value);
                });
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            },
            
            generateData() {
                // Clear any existing array data
                this.arrays = [];
                this.comparisons = [];
                this.movements = [];
                this.currentStep = 0;
                
                // Generate initial array based on selected pattern
                let initialArray = [];
                
                switch (this.dataPattern) {
                    case 'random':
                        initialArray = Array.from({ length: this.dataSize }, () => Math.floor(Math.random() * this.dataSize) + 1);
                        break;
                    case 'nearlySorted':
                        initialArray = Array.from({ length: this.dataSize }, (_, i) => i + 1);
                        // Swap about 10% of elements randomly
                        const swaps = Math.floor(this.dataSize * 0.1);
                        for (let i = 0; i < swaps; i++) {
                            const idx1 = Math.floor(Math.random() * this.dataSize);
                            const idx2 = Math.floor(Math.random() * this.dataSize);
                            [initialArray[idx1], initialArray[idx2]] = [initialArray[idx2], initialArray[idx1]];
                        }
                        break;
                    case 'reversed':
                        initialArray = Array.from({ length: this.dataSize }, (_, i) => this.dataSize - i);
                        break;
                }
                
                // Store initial array
                this.arrays.push([...initialArray]);
                
                // Create visualization of initial array
                this.createVisualization();
            },
            
            createVisualization() {
                // Clear existing visualization elements
                this.clearVisualization();
                
                // Create bars for the initial array
                this.createArrayBars(this.arrays[0], 0);
            },
            
            clearVisualization() {
                // Remove all existing array bars, comparison lines, and movement trails
                for (let i = this.scene.children.length - 1; i >= 0; i--) {
                    const child = this.scene.children[i];
                    if (child.type === 'Group' || 
                        (child.userData && (child.userData.type === 'arrayBar' || 
                                            child.userData.type === 'comparisonLine' || 
                                            child.userData.type === 'movementTrail'))) {
                        this.scene.remove(child);
                    }
                }
                
                // Clear stored visualization objects
                this.comparisonLines = [];
                this.movementTrails = [];
            },
            
            createArrayBars(array, step) {
                const spacing = 2;
                const barWidth = 1;
                const maxHeight = 40;
                
                // Create a group for this step
                const stepGroup = new THREE.Group();
                stepGroup.position.z = -step * 5; // Position each step along z-axis
                this.scene.add(stepGroup);
                
                // Create bars
                array.forEach((value, index) => {
                    const height = (value / this.dataSize) * maxHeight;
                    const geometry = new THREE.BoxGeometry(barWidth, height, barWidth);
                    
                    // Calculate how far this element is from its correct position
                    // For most sorts, the correct position is where value = index+1 
                    // (assuming 1-based values from 1 to dataSize)
                    const correctIndex = value - 1;
                    const distanceFromCorrect = Math.abs(index - correctIndex);
                    const normalizedDistance = 1 - (distanceFromCorrect / this.dataSize);
                    
                    // Color based on closeness to correct position
                    // More correct = brighter color
                    let color;
                    if (distanceFromCorrect === 0) {
                        // Perfect position - bright white
                        color = new THREE.Color(1, 1, 1);
                    } else {
                        // Base hue on value (rainbow gradient like before)
                        const hue = (value / this.dataSize) * 0.8;
                        
                        // Brightness (lightness) based on closeness to correct position
                        // Range from 0.3 (far) to 0.9 (close)
                        const lightness = 0.3 + (normalizedDistance * 0.6);
                        
                        color = new THREE.Color().setHSL(hue, 1.0, lightness);
                    }
                    
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color,
                        emissive: color.clone().multiplyScalar(0.3)
                    });
                    
                    const bar = new THREE.Mesh(geometry, material);
                    
                    // Position bar
                    bar.position.x = (index - this.dataSize / 2) * spacing;
                    bar.position.y = height / 2;
                    
                    // Store original index for tracking
                    bar.userData = {
                        type: 'arrayBar',
                        value: value,
                        originalIndex: index,
                        currentIndex: index,
                        step: step,
                        correctPosition: (index === correctIndex)
                    };
                    
                    stepGroup.add(bar);
                });
                
                return stepGroup;
            },
            
            runSortingAlgorithm() {
                // Get a copy of the initial array
                const array = [...this.arrays[0]];
                
                // Reset algorithm steps
                this.algorithmSteps = [];
                this.comparisons = [];
                this.movements = [];
                
                // Execute selected sorting algorithm and record steps
                switch (this.algorithm) {
                    case 'bubble':
                        this.bubbleSort(array);
                        break;
                    case 'insertion':
                        this.insertionSort(array);
                        break;
                    case 'selection':
                        this.selectionSort(array);
                        break;
                    case 'quick':
                        this.quickSort(array, 0, array.length - 1);
                        break;
                    case 'merge':
                        this.mergeSort(array, 0, array.length - 1);
                        break;
                }
                
                // Visualize all recorded steps
                this.visualizeAlgorithmSteps();
            },
            
            bubbleSort(array) {
                const n = array.length;
                let swapped;
                
                do {
                    swapped = false;
                    for (let i = 0; i < n - 1; i++) {
                        // Record comparison
                        this.comparisons.push([i, i + 1]);
                        
                        if (array[i] > array[i + 1]) {
                            // Record movement
                            this.movements.push([i, i + 1]);
                            
                            // Swap elements
                            [array[i], array[i + 1]] = [array[i + 1], array[i]];
                            swapped = true;
                            
                            // Record array state after swap
                            this.arrays.push([...array]);
                        }
                    }
                } while (swapped);
            },
            
            insertionSort(array) {
                const n = array.length;
                
                for (let i = 1; i < n; i++) {
                    const key = array[i];
                    let j = i - 1;
                    
                    while (j >= 0 && array[j] > key) {
                        // Record comparison
                        this.comparisons.push([j, j + 1]);
                        
                        // Record movement
                        this.movements.push([j, j + 1]);
                        
                        array[j + 1] = array[j];
                        j--;
                        
                        // Record array state after each shift
                        this.arrays.push([...array]);
                    }
                    
                    array[j + 1] = key;
                    
                    // Record final array state after insertion
                    this.arrays.push([...array]);
                }
            },
            
            selectionSort(array) {
                const n = array.length;
                
                for (let i = 0; i < n - 1; i++) {
                    let minIdx = i;
                    
                    for (let j = i + 1; j < n; j++) {
                        // Record comparison
                        this.comparisons.push([minIdx, j]);
                        
                        if (array[j] < array[minIdx]) {
                            minIdx = j;
                        }
                    }
                    
                    if (minIdx !== i) {
                        // Record movement
                        this.movements.push([i, minIdx]);
                        
                        // Swap elements
                        [array[i], array[minIdx]] = [array[minIdx], array[i]];
                        
                        // Record array state after swap
                        this.arrays.push([...array]);
                    }
                }
            },
            
            quickSort(array, low, high) {
                if (low < high) {
                    const pivotIndex = this.partition(array, low, high);
                    
                    this.quickSort(array, low, pivotIndex - 1);
                    this.quickSort(array, pivotIndex + 1, high);
                }
            },
            
            partition(array, low, high) {
                const pivot = array[high];
                let i = low - 1;
                
                for (let j = low; j < high; j++) {
                    // Record comparison with pivot
                    this.comparisons.push([j, high]);
                    
                    if (array[j] < pivot) {
                        i++;
                        
                        // Record movement
                        this.movements.push([i, j]);
                        
                        // Swap elements
                        [array[i], array[j]] = [array[j], array[i]];
                        
                        // Record array state after swap
                        this.arrays.push([...array]);
                    }
                }
                
                // Move pivot to its final position
                if (i + 1 !== high) {
                    // Record movement
                    this.movements.push([i + 1, high]);
                    
                    // Swap elements
                    [array[i + 1], array[high]] = [array[high], array[i + 1]];
                    
                    // Record array state after swap
                    this.arrays.push([...array]);
                }
                
                return i + 1;
            },
            
            mergeSort(array, left, right) {
                if (left < right) {
                    const mid = Math.floor((left + right) / 2);
                    
                    this.mergeSort(array, left, mid);
                    this.mergeSort(array, mid + 1, right);
                    
                    this.merge(array, left, mid, right);
                }
            },
            
            merge(array, left, mid, right) {
                const n1 = mid - left + 1;
                const n2 = right - mid;
                
                // Create temp arrays
                const L = new Array(n1);
                const R = new Array(n2);
                
                // Copy data to temp arrays
                for (let i = 0; i < n1; i++) {
                    L[i] = array[left + i];
                }
                for (let j = 0; j < n2; j++) {
                    R[j] = array[mid + 1 + j];
                }
                
                // Merge temp arrays back into array[left..right]
                let i = 0;
                let j = 0;
                let k = left;
                
                while (i < n1 && j < n2) {
                    // Record comparison
                    this.comparisons.push([left + i, mid + 1 + j]);
                    
                    if (L[i] <= R[j]) {
                        if (array[k] !== L[i]) {
                            // Record movement
                            this.movements.push([k, left + i]);
                            
                            // Update array
                            array[k] = L[i];
                            
                            // Record array state after change
                            this.arrays.push([...array]);
                        }
                        i++;
                    } else {
                        if (array[k] !== R[j]) {
                            // Record movement
                            this.movements.push([k, mid + 1 + j]);
                            
                            // Update array
                            array[k] = R[j];
                            
                            // Record array state after change
                            this.arrays.push([...array]);
                        }
                        j++;
                    }
                    k++;
                }
                
                // Copy remaining elements of L[]
                while (i < n1) {
                    if (array[k] !== L[i]) {
                        // Record movement
                        this.movements.push([k, left + i]);
                        
                        // Update array
                        array[k] = L[i];
                        
                        // Record array state after change
                        this.arrays.push([...array]);
                    }
                    i++;
                    k++;
                }
                
                // Copy remaining elements of R[]
                while (j < n2) {
                    if (array[k] !== R[j]) {
                        // Record movement
                        this.movements.push([k, mid + 1 + j]);
                        
                        // Update array
                        array[k] = R[j];
                        
                        // Record array state after change
                        this.arrays.push([...array]);
                    }
                    j++;
                    k++;
                }
            },
            
            visualizeAlgorithmSteps() {
                // Clear existing visualization
                this.clearVisualization();
                
                // Only create visualization for initial array at first
                this.createArrayBars(this.arrays[0], 0);
                
                // Reset current step
                this.currentStep = 0;
                
                // Update comparisons and movements for current step
                this.updateVisualization();
            },
            
            // Called from animation loop when animating
            advanceStep() {
                if (this.currentStep < this.arrays.length - 1) {
                    this.currentStep++;
                    
                    // Create visualization for this step only if it doesn't exist yet
                    const stepZ = -this.currentStep * 5;
                    const existingGroup = this.scene.children.find(c => 
                        c.type === 'Group' && Math.abs(c.position.z - stepZ) < 0.1);
                    
                    if (!existingGroup) {
                        this.createArrayBars(this.arrays[this.currentStep], this.currentStep);
                    }
                    
                    this.updateVisualization();
                } else {
                    // Animation complete
                    this.isAnimating = false;
                }
            },
            
            updateVisualization() {
                // Clear existing comparison lines and movement trails
                this.scene.children.forEach(child => {
                    if (child.userData && (child.userData.type === 'comparisonLine' || child.userData.type === 'movementTrail')) {
                        this.scene.remove(child);
                    }
                });
                
                this.comparisonLines = [];
                this.movementTrails = [];
                
                // Get current step bars
                const currentStepBars = this.scene.children.filter(child => 
                    child.type === 'Group' && child.position.z === -this.currentStep * 5);
                
                if (currentStepBars.length === 0) return;
                
                const bars = currentStepBars[0].children;
                
                // Show comparisons for current step
                if (this.showComparisons && this.currentStep < this.comparisons.length) {
                    const comparison = this.comparisons[this.currentStep];
                    this.visualizeComparison(bars, comparison);
                }
                
                // Show movements for current step
                if (this.showMovement && this.currentStep < this.movements.length) {
                    const movement = this.movements[this.currentStep];
                    this.visualizeMovement(bars, movement);
                }
            },
            
            visualizeComparison(bars, comparison) {
                const [idx1, idx2] = comparison;
                
                if (idx1 >= 0 && idx1 < bars.length && idx2 >= 0 && idx2 < bars.length) {
                    const bar1 = bars[idx1];
                    const bar2 = bars[idx2];
                    
                    // Create line geometry
                    const points = [
                        new THREE.Vector3(bar1.position.x, bar1.position.y + 2, 0),
                        new THREE.Vector3(bar2.position.x, bar2.position.y + 2, 0)
                    ];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ 
                        color: 0xffff00,
                        linewidth: 2,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.userData = { type: 'comparisonLine' };
                    
                    this.scene.add(line);
                    this.comparisonLines.push(line);
                }
            },
            
            visualizeMovement(bars, movement) {
                const [idx1, idx2] = movement;
                
                if (idx1 >= 0 && idx1 < bars.length && idx2 >= 0 && idx2 < bars.length) {
                    const bar1 = bars[idx1];
                    const bar2 = bars[idx2];
                    
                    // Create curved line geometry for movement
                    const curve = new THREE.QuadraticBezierCurve3(
                        new THREE.Vector3(bar1.position.x, bar1.position.y, 0),
                        new THREE.Vector3((bar1.position.x + bar2.position.x) / 2, 
                                        Math.max(bar1.position.y, bar2.position.y) + 10, 0),
                        new THREE.Vector3(bar2.position.x, bar2.position.y, 0)
                    );
                    
                    const points = curve.getPoints(20);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    const material = new THREE.LineBasicMaterial({
                        color: 0xff6600,
                        linewidth: 2,
                        transparent: true,
                        opacity: 0.6
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.userData = { type: 'movementTrail' };
                    
                    this.scene.add(line);
                    this.movementTrails.push(line);
                    
                    // Update color of the bars that moved
                    bar1.material.emissive.setRGB(0.8, 0.2, 0.2);
                    bar2.material.emissive.setRGB(0.2, 0.8, 0.2);
                }
            },
            
            // Main animation loop
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.stats.begin();
                
                // Update camera position with smooth interpolation
                if (this.camera.position.distanceTo(this.cameraTarget.position) > 0.1) {
                    this.camera.position.lerp(this.cameraTarget.position, 0.05);
                    // Update lookAt only during camera movement
                    this.camera.lookAt(this.cameraTarget.lookAt);
                    // Update controls target
                    this.controls.target.lerp(this.cameraTarget.lookAt, 0.05);
                    this.controls.update();
                }
                
                // Step through algorithm if animating
                if (this.isAnimating) {
                    // Add delay based on animation speed
                    if (this.frame % (11 - this.animationSpeed) === 0) {
                        // Store old step to detect changes
                        const oldStep = this.currentStep;
                        
                        // Advance to next step
                        this.advanceStep();
                        
                        // Only update camera target if step actually changed
                        if (oldStep !== this.currentStep && this.currentStep > 5) {
                            // Calculate target z position based on current step
                            const targetZ = -this.currentStep * 5 - 20; // -20 to look ahead
                            
                            // Update camera target for smooth interpolation
                            // Position camera more overhead for clearer view of all values
                            this.cameraTarget.position.set(20, 150, targetZ);
                            // Look directly at the array
                            this.cameraTarget.lookAt.set(0, 0, targetZ - 10);
                        }
                    }
                    
                    this.frame++;
                }
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
                
                this.stats.end();
            },
            
            // Reset the visualization
            reset() {
                this.isAnimating = false;
                this.currentStep = 0;
                this.frame = 0;
                
                // Clear existing visualization
                this.clearVisualization();
                
                // Reset arrays and tracking data
                this.arrays = [];
                this.comparisons = [];
                this.movements = [];
                this.algorithmSteps = [];
                
                // Generate new data
                this.generateData();
                
                // Reset camera target for smooth interpolation
                this.cameraTarget.position.set(30, 120, 30);
                this.cameraTarget.lookAt.set(0, 0, 0);
                
                // Force immediate camera reset without interpolation
                this.camera.position.copy(this.cameraTarget.position);
                this.camera.lookAt(this.cameraTarget.lookAt);
                this.controls.target.copy(this.cameraTarget.lookAt);
                this.controls.update();
            },
            
            frame: 0
        };
        
        // Initialize the application
        window.addEventListener('load', () => {
            app.init();
        });
    </script>
</body>
</html>
