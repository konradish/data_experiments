<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Sorting Algorithm Visualization for ML Pattern Analysis</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        select, button {
            margin: 5px 0;
            padding: 5px;
            width: 100%;
        }
        .collapsible-header {
            cursor: pointer;
            padding: 5px;
            background: rgba(255,255,255,0.1);
            margin-bottom: 5px;
            border-radius: 3px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .collapsible-header::after {
            content: '[-]'; /* Collapse symbol */
            font-weight: bold;
            margin-left: 10px;
        }
        .collapsed .collapsible-header::after {
            content: '[+]'; /* Expand symbol */
        }
        .collapsed .collapsible-content {
            display: none;
        }

        /* Mobile Styles */
        @media (max-width: 768px) {
            #info, #controls {
                position: relative; /* Change from absolute */
                width: 90%;
                max-width: none;
                top: auto;
                left: auto;
                right: auto;
                margin: 10px auto; /* Center the panels */
                float: none; /* Ensure they don't float */
                font-size: 14px; /* Slightly smaller font */
            }
            #info { order: 1; } /* Optional: Control order on mobile */
            #controls { order: 2; }
            body { display: flex; flex-direction: column; } /* Allow panels to stack */
            canvas { order: 0; } /* Keep canvas first */
        }
        @media (max-width: 480px) {
             #info, #controls {
                 font-size: 12px;
                 padding: 8px;
             }
             select, button {
                 padding: 8px; /* Easier tapping */
                 font-size: 12px;
             }
             .collapsible-header {
                 padding: 8px;
             }
             /* Optionally collapse by default on very small screens */
             /*
             #info, #controls {
                 &.collapsed .collapsible-content { display: none; }
             }
             */
        }
    </style>
</head>
<body>
    <div id="info"> <!-- Add 'collapsed' class here to start collapsed -->
        <h4 class="collapsible-header">Info / Help</h4>
        <div class="collapsible-content">
            <h2>Sorting Algorithm Visualization</h2>
            <p>This visualization shows sorting algorithms in 3D space, with time as the third dimension.</p>
            <p>Features:</p>
            <ul>
                <li>Element positions shown as colored bars</li>
                <li>Comparisons visualized as connecting lines</li>
                <li>Movement tracking with color fading</li>
                <li>3D time progression to observe patterns</li>
            </ul>
            <p>Rotate: Right-click + drag</p> 
            <p>Zoom: Scroll wheel</p>
            <p>Pan: Left-click + drag</p> 
        </div>
    </div>
    <div id="controls"> <!-- Add 'collapsed' class here to start collapsed -->
        <h4 class="collapsible-header">Controls</h4>
        <div class="collapsible-content">
            <h3>Settings</h3>
            <select id="algorithm">
                <option value="bubble">Bubble Sort</option>
                <option value="insertion">Insertion Sort</option>
            <option value="selection">Selection Sort</option>
            <option value="quick">Quick Sort</option>
            <option value="merge">Merge Sort</option>
        </select>
        <select id="dataSize">
            <option value="20">20 Elements</option>
            <option value="50">50 Elements</option>
            <option value="100">100 Elements</option>
        </select>
        <select id="dataPattern">
            <option value="random">Random</option>
            <option value="nearlySorted">Nearly Sorted</option>
            <option value="reversed">Reversed</option>
        </select>
        <button id="startBtn">Start Sorting</button>
        <button id="resetBtn">Reset</button>
        <div>
            <label><input type="checkbox" id="showComparisons" checked> Show Comparisons</label>
        </div>
        <div>
            <label><input type="checkbox" id="showMovement" checked> Track Movement</label>
        </div>
        <div>
            <label>Animation Speed: <input type="range" id="speed" min="1" max="10" value="5"></label>
        </div>
        </div> <!-- Close collapsible-content -->
    </div>

    <!-- Import Three.js library and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat.gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/16/Stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    
    <!-- Import OrbitControls from Three.js examples -->
    <script>
        // OrbitControls implementation from Three.js examples
        // https://github.com/mrdoob/three.js/blob/master/examples/js/controls/OrbitControls.js
        THREE.OrbitControls = function ( object, domElement ) {

            this.object = object;
            this.domElement = ( domElement !== undefined ) ? domElement : document;

            // Set to false to disable this control
            this.enabled = true;

            // "target" sets the location of focus, where the object orbits around
            this.target = new THREE.Vector3();

            // How far you can dolly in and out ( PerspectiveCamera only )
            this.minDistance = 0;
            this.maxDistance = Infinity;

            // How far you can zoom in and out ( OrthographicCamera only )
            this.minZoom = 0;
            this.maxZoom = Infinity;

            // How far you can orbit vertically, upper and lower limits.
            // Range is 0 to Math.PI radians.
            this.minPolarAngle = 0; // radians
            this.maxPolarAngle = Math.PI; // radians

            // How far you can orbit horizontally, upper and lower limits.
            // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
            this.minAzimuthAngle = - Infinity; // radians
            this.maxAzimuthAngle = Infinity; // radians

            // Set to true to enable damping (inertia)
            // If damping is enabled, you must call controls.update() in your animation loop
            this.enableDamping = false;
            this.dampingFactor = 0.25;

            // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
            // Set to false to disable zooming
            this.enableZoom = true;
            this.zoomSpeed = 1.0;

            // Set to false to disable rotating
            this.enableRotate = true;
            this.rotateSpeed = 1.0;

            // Set to false to disable panning
            this.enablePan = true;
            this.panSpeed = 1.0;
            this.screenSpacePanning = false; // if true, pan in screen-space
            this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

            // Set to true to automatically rotate around the target
            // If auto-rotate is enabled, you must call controls.update() in your animation loop
            this.autoRotate = false;
            this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

            // Set to false to disable use of the keys
            this.enableKeys = true;

            // The four arrow keys
            this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

            // Mouse buttons
            this.mouseButtons = { LEFT: THREE.MOUSE.LEFT, MIDDLE: THREE.MOUSE.MIDDLE, RIGHT: THREE.MOUSE.RIGHT };

            // for reset
            this.target0 = this.target.clone();
            this.position0 = this.object.position.clone();
            this.zoom0 = this.object.zoom;

            //
            // public methods
            //

            this.getPolarAngle = function () {
                return spherical.phi;
            };

            this.getAzimuthalAngle = function () {
                return spherical.theta;
            };

            this.saveState = function () {
                scope.target0.copy( scope.target );
                scope.position0.copy( scope.object.position );
                scope.zoom0 = scope.object.zoom;
            };

            this.reset = function () {
                scope.target.copy( scope.target0 );
                scope.object.position.copy( scope.position0 );
                scope.object.zoom = scope.zoom0;

                scope.object.updateProjectionMatrix();
                scope.dispatchEvent( changeEvent );

                scope.update();

                state = STATE.NONE;
            };

            // this method is exposed, but perhaps it would be better if we can make it private...
            this.update = function () {

                var offset = new THREE.Vector3();

                // so camera.up is the orbit axis
                var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
                var quatInverse = quat.clone().inverse();

                var lastPosition = new THREE.Vector3();
                var lastQuaternion = new THREE.Quaternion();

                return function update() {

                    var position = scope.object.position;

                    offset.copy( position ).sub( scope.target );

                    // rotate offset to "y-axis-is-up" space
                    offset.applyQuaternion( quat );

                    // angle from z-axis around y-axis
                    spherical.setFromVector3( offset );

                    if ( scope.autoRotate && state === STATE.NONE ) {
                        rotateLeft( getAutoRotationAngle() );
                    }

                    spherical.theta += sphericalDelta.theta;
                    spherical.phi += sphericalDelta.phi;

                    // restrict theta to be between desired limits
                    spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

                    // restrict phi to be between desired limits
                    spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

                    spherical.makeSafe();

                    spherical.radius *= scale;

                    // restrict radius to be between desired limits
                    spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

                    // move target to panned location
                    scope.target.add( panOffset );

                    offset.setFromSpherical( spherical );

                    // rotate offset back to "camera-up-vector-is-up" space
                    offset.applyQuaternion( quatInverse );

                    position.copy( scope.target ).add( offset );

                    scope.object.lookAt( scope.target );

                    if ( scope.enableDamping === true ) {
                        sphericalDelta.theta *= ( 1 - scope.dampingFactor );
                        sphericalDelta.phi *= ( 1 - scope.dampingFactor );
                        panOffset.multiplyScalar( 1 - scope.dampingFactor );
                    } else {
                        sphericalDelta.set( 0, 0, 0 );
                        panOffset.set( 0, 0, 0 );
                    }

                    scale = 1;

                    // update condition is:
                    // min(camera displacement, camera rotation in radians)^2 > EPS
                    // using small-angle approximation cos(x/2) = 1 - x^2 / 8

                    if ( zoomChanged ||
                        lastPosition.distanceToSquared( scope.object.position ) > EPS ||
                        8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

                        scope.dispatchEvent( changeEvent );

                        lastPosition.copy( scope.object.position );
                        lastQuaternion.copy( scope.object.quaternion );
                        zoomChanged = false;

                        return true;
                    }

                    return false;
                };
            }();

            this.dispose = function () {
                scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
                scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
                scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

                scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
                scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
                scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

                document.removeEventListener( 'mousemove', onMouseMove, false );
                document.removeEventListener( 'mouseup', onMouseUp, false );

                window.removeEventListener( 'keydown', onKeyDown, false );
            };

            //
            // internals
            //

            var scope = this;

            var changeEvent = { type: 'change' };
            var startEvent = { type: 'start' };
            var endEvent = { type: 'end' };

            var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };

            var state = STATE.NONE;

            var EPS = 0.000001;

            // current position in spherical coordinates
            var spherical = new THREE.Spherical();
            var sphericalDelta = new THREE.Spherical();

            var scale = 1;
            var panOffset = new THREE.Vector3();
            var zoomChanged = false;

            var rotateStart = new THREE.Vector2();
            var rotateEnd = new THREE.Vector2();
            var rotateDelta = new THREE.Vector2();

            var panStart = new THREE.Vector2();
            var panEnd = new THREE.Vector2();
            var panDelta = new THREE.Vector2();

            var dollyStart = new THREE.Vector2();
            var dollyEnd = new THREE.Vector2();
            var dollyDelta = new THREE.Vector2();

            function getAutoRotationAngle() {
                return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
            }

            function getZoomScale() {
                return Math.pow( 0.95, scope.zoomSpeed );
            }

            function rotateLeft( angle ) {
                sphericalDelta.theta -= angle;
            }

            function rotateUp( angle ) {
                sphericalDelta.phi -= angle;
            }

            var panLeft = function () {
                var v = new THREE.Vector3();

                return function panLeft( distance, objectMatrix ) {
                    v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
                    v.multiplyScalar( - distance );
                    panOffset.add( v );
                };
            }();

            var panUp = function () {
                var v = new THREE.Vector3();

                return function panUp( distance, objectMatrix ) {
                    if ( scope.screenSpacePanning === true ) {
                        v.setFromMatrixColumn( objectMatrix, 1 );
                    } else {
                        v.setFromMatrixColumn( objectMatrix, 0 );
                        v.crossVectors( scope.object.up, v );
                    }
                    v.multiplyScalar( distance );
                    panOffset.add( v );
                };
            }();

            // deltaX and deltaY are in pixels; right and down are positive
            var pan = function () {
                var offset = new THREE.Vector3();

                return function pan( deltaX, deltaY ) {
                    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                    if ( scope.object.isPerspectiveCamera ) {
                        // perspective
                        var position = scope.object.position;
                        offset.copy( position ).sub( scope.target );
                        var targetDistance = offset.length();

                        // half of the fov is center to top of screen
                        targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

                        // we use only clientHeight here so aspect ratio does not distort speed
                        panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
                        panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );
                    } else if ( scope.object.isOrthographicCamera ) {
                        // orthographic
                        panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
                        panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );
                    } else {
                        // camera neither orthographic nor perspective
                        console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
                        scope.enablePan = false;
                    }
                };
            }();

            function dollyIn( dollyScale ) {
                if ( scope.object.isPerspectiveCamera ) {
                    scale /= dollyScale;
                } else if ( scope.object.isOrthographicCamera ) {
                    scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
                    scope.object.updateProjectionMatrix();
                    zoomChanged = true;
                } else {
                    console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                    scope.enableZoom = false;
                }
            }

            function dollyOut( dollyScale ) {
                if ( scope.object.isPerspectiveCamera ) {
                    scale *= dollyScale;
                } else if ( scope.object.isOrthographicCamera ) {
                    scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
                    scope.object.updateProjectionMatrix();
                    zoomChanged = true;
                } else {
                    console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
                    scope.enableZoom = false;
                }
            }

            //
            // event callbacks - update the object state
            //

            function handleMouseDownRotate( event ) {
                rotateStart.set( event.clientX, event.clientY );
            }

            function handleMouseDownDolly( event ) {
                dollyStart.set( event.clientX, event.clientY );
            }

            function handleMouseDownPan( event ) {
                panStart.set( event.clientX, event.clientY );
            }

            function handleMouseMoveRotate( event ) {
                rotateEnd.set( event.clientX, event.clientY );
                rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height
                rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

                rotateStart.copy( rotateEnd );

                scope.update();
            }

            function handleMouseMoveDolly( event ) {
                dollyEnd.set( event.clientX, event.clientY );
                dollyDelta.subVectors( dollyEnd, dollyStart );

                if ( dollyDelta.y > 0 ) {
                    dollyIn( getZoomScale() );
                } else if ( dollyDelta.y < 0 ) {
                    dollyOut( getZoomScale() );
                }

                dollyStart.copy( dollyEnd );
                scope.update();
            }

            function handleMouseMovePan( event ) {
                panEnd.set( event.clientX, event.clientY );
                panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

                pan( panDelta.x, panDelta.y );

                panStart.copy( panEnd );
                scope.update();
            }

            function handleMouseUp( /*event*/ ) {
                // no-op
            }

            function handleMouseWheel( event ) {
                if ( event.deltaY < 0 ) {
                    dollyOut( getZoomScale() );
                } else if ( event.deltaY > 0 ) {
                    dollyIn( getZoomScale() );
                }

                scope.update();
            }

            function handleKeyDown( event ) {
                var needsUpdate = false;

                switch ( event.keyCode ) {
                    case scope.keys.UP:
                        pan( 0, scope.keyPanSpeed );
                        needsUpdate = true;
                        break;

                    case scope.keys.BOTTOM:
                        pan( 0, - scope.keyPanSpeed );
                        needsUpdate = true;
                        break;

                    case scope.keys.LEFT:
                        pan( scope.keyPanSpeed, 0 );
                        needsUpdate = true;
                        break;

                    case scope.keys.RIGHT:
                        pan( - scope.keyPanSpeed, 0 );
                        needsUpdate = true;
                        break;
                }

                if ( needsUpdate ) {
                    // prevent the browser from scrolling on cursor keys
                    event.preventDefault();
                    scope.update();
                }
            }

            function handleTouchStartRotate( event ) {
                if ( event.touches.length == 1 ) {
                    rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                } else {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

                    rotateStart.set( x, y );
                }
            }

            function handleTouchStartDollyPan( event ) {
                if ( scope.enableZoom ) {
                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

                    var distance = Math.sqrt( dx * dx + dy * dy );

                    dollyStart.set( 0, distance );
                }

                if ( scope.enablePan ) {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

                    panStart.set( x, y );
                }
            }

            function handleTouchMoveRotate( event ) {
                if ( event.touches.length == 1 ) {
                    rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
                } else {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

                    rotateEnd.set( x, y );
                }

                rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height
                rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

                rotateStart.copy( rotateEnd );
            }

            function handleTouchMoveDollyPan( event ) {
                if ( scope.enableZoom ) {
                    var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
                    var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

                    var distance = Math.sqrt( dx * dx + dy * dy );

                    dollyEnd.set( 0, distance );
                    dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

                    dollyIn( dollyDelta.y );
                    dollyStart.copy( dollyEnd );
                }

                if ( scope.enablePan ) {
                    var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
                    var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

                    panEnd.set( x, y );
                    panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

                    pan( panDelta.x, panDelta.y );
                    panStart.copy( panEnd );
                }

                scope.update();
            }

            function handleTouchEnd( /*event*/ ) {
                // no-op
            }

            //
            // event handlers - FSM: listen for events and reset state
            //

            function onMouseDown( event ) {
                if ( scope.enabled === false ) return;

                // Prevent the browser from scrolling.
                event.preventDefault();

                // Manually set the focus since calling preventDefault above
                // prevents the browser from setting it automatically.

                scope.domElement.focus ? scope.domElement.focus() : window.focus();

                switch ( event.button ) {
                    case scope.mouseButtons.LEFT:
                        if ( event.ctrlKey || event.metaKey || event.shiftKey ) {
                            if ( scope.enablePan === false ) return;
                            handleMouseDownPan( event );
                            state = STATE.PAN;
                        } else {
                            if ( scope.enableRotate === false ) return;
                            handleMouseDownRotate( event );
                            state = STATE.ROTATE;
                        }
                        break;

                    case scope.mouseButtons.MIDDLE:
                        if ( scope.enableZoom === false ) return;
                        handleMouseDownDolly( event );
                        state = STATE.DOLLY;
                        break;

                    case scope.mouseButtons.RIGHT:
                        if ( scope.enablePan === false ) return;
                        handleMouseDownPan( event );
                        state = STATE.PAN;
                        break;
                }

                if ( state !== STATE.NONE ) {
                    document.addEventListener( 'mousemove', onMouseMove, false );
                    document.addEventListener( 'mouseup', onMouseUp, false );
                    scope.dispatchEvent( startEvent );
                }
            }

            function onMouseMove( event ) {
                if ( scope.enabled === false ) return;

                event.preventDefault();

                switch ( state ) {
                    case STATE.ROTATE:
                        if ( scope.enableRotate === false ) return;
                        handleMouseMoveRotate( event );
                        break;

                    case STATE.DOLLY:
                        if ( scope.enableZoom === false ) return;
                        handleMouseMoveDolly( event );
                        break;

                    case STATE.PAN:
                        if ( scope.enablePan === false ) return;
                        handleMouseMovePan( event );
                        break;
                }
            }

            function onMouseUp( event ) {
                if ( scope.enabled === false ) return;

                handleMouseUp( event );

                document.removeEventListener( 'mousemove', onMouseMove, false );
                document.removeEventListener( 'mouseup', onMouseUp, false );

                scope.dispatchEvent( endEvent );

                state = STATE.NONE;
            }

            function onMouseWheel( event ) {
                if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

                event.preventDefault();
                event.stopPropagation();

                scope.dispatchEvent( startEvent );
                handleMouseWheel( event );
                scope.dispatchEvent( endEvent );
            }

            function onKeyDown( event ) {
                if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;
                handleKeyDown( event );
            }

            function onTouchStart( event ) {
                if ( scope.enabled === false ) return;

                event.preventDefault();

                switch ( event.touches.length ) {
                    case 1:	// one-fingered touch: rotate
                        if ( scope.enableRotate === false ) return;
                        handleTouchStartRotate( event );
                        state = STATE.TOUCH_ROTATE;
                        break;

                    case 2:	// two-fingered touch: dolly-pan
                        if ( scope.enableZoom === false && scope.enablePan === false ) return;
                        handleTouchStartDollyPan( event );
                        state = STATE.TOUCH_DOLLY_PAN;
                        break;

                    default:
                        state = STATE.NONE;
                }

                if ( state !== STATE.NONE ) {
                    scope.dispatchEvent( startEvent );
                }
            }

            function onTouchMove( event ) {
                if ( scope.enabled === false ) return;

                event.preventDefault();
                event.stopPropagation();

                switch ( event.touches.length ) {
                    case 1: // one-fingered touch: rotate
                        if ( scope.enableRotate === false ) return;
                        if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?
                        handleTouchMoveRotate( event );
                        break;

                    case 2: // two-fingered touch: dolly-pan
                        if ( scope.enableZoom === false && scope.enablePan === false ) return;
                        if ( state !== STATE.TOUCH_DOLLY_PAN ) return; // is this needed?
                        handleTouchMoveDollyPan( event );
                        break;

                    default:
                        state = STATE.NONE;
                }
            }

            function onTouchEnd( event ) {
                if ( scope.enabled === false ) return;

                handleTouchEnd( event );
                scope.dispatchEvent( endEvent );
                state = STATE.NONE;
            }

            function onContextMenu( event ) {
                if ( scope.enabled === false ) return;
                event.preventDefault();
            }

            //

            scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );
            scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
            scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

            scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
            scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
            scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

            window.addEventListener( 'keydown', onKeyDown, false );

            // force an update at start
            this.update();
        };

        THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
        THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
    </script>

    <script>
        // Main application
        const app = {
            scene: null,
            camera: null,
            renderer: null,
            controls: null,
            arrays: [],
            comparisons: [],
            movements: [],
            currentStep: 0,
            isAnimating: false,
            animationSpeed: 5,
            showComparisons: true,
            showMovement: true,
            dataSize: 20,
            algorithm: 'bubble',
            dataPattern: 'random',
            algorithmSteps: [],
            comparisonLines: [],
            movementTrails: [],
            stats: null,
            isUserInteracting: false, // Flag for camera interaction
            cameraTarget: { // For smooth camera animation
                position: new THREE.Vector3(),
                lookAt: new THREE.Vector3()
            },
            
            init() {
                // Create Three.js scene
                this.scene = new THREE.Scene();
                // Slightly lighter background now that scene lights are removed
                this.scene.background = new THREE.Color(0x202030); 
                
                // Camera setup - more overhead angle
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                // Start slightly ahead (more negative Z)
                this.camera.position.set(0, 80, -50); 
                this.camera.lookAt(0, 0, -70); // Look slightly further ahead initially
                
                // Initialize camera target state
                this.cameraTarget.position.copy(this.camera.position);
                this.cameraTarget.lookAt.copy(this.controls ? this.controls.target : new THREE.Vector3(0, 0, 0));
                
                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);
                
                // Orbit controls with modified mouse buttons
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.25;
                this.controls.rotateSpeed = 0.5;
                this.controls.zoomSpeed = 0.6;
                this.controls.panSpeed = 0.5;
                // Swap mouse buttons - left for pan, right for rotate
                this.controls.mouseButtons = {
                    LEFT: THREE.MOUSE.PAN,
                    MIDDLE: THREE.MOUSE.DOLLY,
                    RIGHT: THREE.MOUSE.ROTATE
                };
                // Disable auto-rotate
                this.controls.autoRotate = false;
                
                // Listen for control interaction events
                this.controls.addEventListener('start', () => { this.isUserInteracting = true; });
                this.controls.addEventListener('end', () => { 
                    // Optional: Add a small delay before resuming auto-camera if desired
                    // setTimeout(() => { this.isUserInteracting = false; }, 500); 
                    this.isUserInteracting = false; 
                });
                
                // Lights removed - relying on emissive materials
                
                // Add grid with extended size
                const gridHelper = new THREE.GridHelper(400, 40, 0x555555, 0x333333);
                this.scene.add(gridHelper);
                
                // Add x, y, z axes
                const axesHelper = new THREE.AxesHelper(50);
                this.scene.add(axesHelper);
                
                // Stats
                this.stats = new Stats();
                this.stats.showPanel(0);
                document.body.appendChild(this.stats.dom);
                
                // Initialize event listeners
                this.initEventListeners();
                
                // Generate initial data
                this.generateData();
                
                // Start animation loop
                this.animate();
            },
            
            initEventListeners() {
                document.getElementById('algorithm').addEventListener('change', (e) => {
                    this.algorithm = e.target.value;
                });
                
                document.getElementById('dataSize').addEventListener('change', (e) => {
                    this.dataSize = parseInt(e.target.value);
                    this.reset();
                });
                
                document.getElementById('dataPattern').addEventListener('change', (e) => {
                    this.dataPattern = e.target.value;
                    this.reset();
                });
                
                document.getElementById('startBtn').addEventListener('click', () => {
                    if (!this.isAnimating) {
                        this.runSortingAlgorithm();
                        this.isAnimating = true;
                    }
                });
                
                document.getElementById('resetBtn').addEventListener('click', () => {
                    this.reset();
                });
                
                document.getElementById('showComparisons').addEventListener('change', (e) => {
                    this.showComparisons = e.target.checked;
                    this.updateVisualization();
                });
                
                document.getElementById('showMovement').addEventListener('change', (e) => {
                    this.showMovement = e.target.checked;
                    this.updateVisualization();
                });
                
                document.getElementById('speed').addEventListener('input', (e) => {
                    // Make speed non-linear (faster at higher values)
                    this.animationSpeed = Math.pow(parseInt(e.target.value), 1.5); 
                });
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // Add listeners for collapsible panels
                document.querySelectorAll('.collapsible-header').forEach(header => {
                    header.addEventListener('click', () => {
                        header.parentElement.classList.toggle('collapsed');
                    });
                });
                // Optional: Start collapsed on mobile?
                // if (window.innerWidth <= 768) {
                //     document.getElementById('info').classList.add('collapsed');
                //     document.getElementById('controls').classList.add('collapsed');
                // }
            },
            
            generateData() {
                // Clear any existing array data
                this.arrays = [];
                this.comparisons = [];
                this.movements = [];
                this.currentStep = 0;
                
                // Generate initial array based on selected pattern
                let initialArray = [];
                
                switch (this.dataPattern) {
                    case 'random':
                        initialArray = Array.from({ length: this.dataSize }, () => Math.floor(Math.random() * this.dataSize) + 1);
                        break;
                    case 'nearlySorted':
                        initialArray = Array.from({ length: this.dataSize }, (_, i) => i + 1);
                        // Swap about 10% of elements randomly
                        const swaps = Math.floor(this.dataSize * 0.1);
                        for (let i = 0; i < swaps; i++) {
                            const idx1 = Math.floor(Math.random() * this.dataSize);
                            const idx2 = Math.floor(Math.random() * this.dataSize);
                            [initialArray[idx1], initialArray[idx2]] = [initialArray[idx2], initialArray[idx1]];
                        }
                        break;
                    case 'reversed':
                        initialArray = Array.from({ length: this.dataSize }, (_, i) => this.dataSize - i);
                        break;
                }
                
                // Store initial array
                this.arrays.push([...initialArray]);
                
                // Create visualization of initial array
                this.createVisualization();
            },
            
            createVisualization() {
                // Clear existing visualization elements
                this.clearVisualization();
                
                // Create bars for the initial array
                this.createArrayBars(this.arrays[0], 0);
            },
            
            clearVisualization() {
                // Remove all existing array bars, comparison lines, and movement trails
                for (let i = this.scene.children.length - 1; i >= 0; i--) {
                    const child = this.scene.children[i];
                    if (child.type === 'Group' || 
                        (child.userData && (child.userData.type === 'arrayBar' || 
                                            child.userData.type === 'comparisonLine' ||
                                            child.userData.type === 'movementTrail'))) {
                        // Dispose geometry and material to free GPU memory
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            // Handle arrays of materials
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                        this.scene.remove(child);
                    }
                }
                
                // Clear stored references
                this.comparisonLines = [];
                this.movementTrails = [];
            },
            
            createArrayBars(array, step) {
                const spacing = 2;
                const barWidth = 1;
                const maxHeight = 40;
                
                // Create a group for this step
                const stepGroup = new THREE.Group();
                stepGroup.position.z = -step * 5; // Position each step along z-axis
                this.scene.add(stepGroup);
                
                // Create bars
                array.forEach((value, index) => {
                    const height = (value / this.dataSize) * maxHeight;
                    const geometry = new THREE.BoxGeometry(barWidth, height, barWidth);
                    
                    // Calculate how far this element is from its correct position
                    // For most sorts, the correct position is where value = index+1 
                    // (assuming 1-based values from 1 to dataSize)
                    const correctIndex = value - 1;
                    const distanceFromCorrect = Math.abs(index - correctIndex);
                    const normalizedDistance = 1 - (distanceFromCorrect / this.dataSize);
                    
                    // Color and Emissive based on closeness to correct position
                    const hue = (value / this.dataSize) * 0.8; // Base hue on value
                    let color = new THREE.Color();
                    let emissiveColor = new THREE.Color();
                    let emissiveIntensity = 0;

                    if (distanceFromCorrect === 0) {
                        // Perfect position - bright color with strong glow
                        const lightness = 0.8; // Bright base color
                        color.setHSL(hue, 1.0, lightness);
                        emissiveColor.copy(color); // Glow with the same color
                        emissiveIntensity = 0.8; // Strong glow
                    } else {
                        // Incorrect position - dimmer color, glow based on closeness
                        // Base lightness lower when incorrect
                        const baseLightness = 0.4; 
                        // Additional lightness based on closeness (0 = far, 0.3 = close)
                        const closenessLightness = normalizedDistance * 0.3; 
                        color.setHSL(hue, 1.0, baseLightness + closenessLightness);
                        
                        emissiveColor.copy(color); // Glow with the bar's color
                        // Emissive intensity based on closeness (0 = far, 0.5 = close)
                        emissiveIntensity = normalizedDistance * 0.5; 
                    }
                    
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color,
                        emissive: emissiveColor,
                        emissiveIntensity: emissiveIntensity
                        // metalness: 0.1, // Optional: Adjust material properties
                        // roughness: 0.6
                    });
                    
                    const bar = new THREE.Mesh(geometry, material);
                    
                    // Position bar
                    bar.position.x = (index - this.dataSize / 2) * spacing;
                    bar.position.y = height / 2;
                    
                    // Store original index for tracking
                    bar.userData = {
                        type: 'arrayBar',
                        value: value,
                        originalIndex: index, // Keep original index
                        currentIndex: index, // Current index within this step's group
                        step: step,
                        correctPosition: (index === correctIndex),
                        lastMoved: -1, // Step number when this bar was last involved in a move
                        baseColor: color.clone(), // Store the calculated base color
                        baseEmissive: emissiveColor.clone(), // Store base emissive color
                        baseEmissiveIntensity: emissiveIntensity // Store base emissive intensity
                    };
                    
                    stepGroup.add(bar);
                });
                
                return stepGroup;
            },
            
            runSortingAlgorithm() {
                // Get a copy of the initial array
                const array = [...this.arrays[0]];
                
                // Reset algorithm steps
                this.algorithmSteps = [];
                this.comparisons = [];
                this.movements = [];
                
                // Execute selected sorting algorithm and record steps
                switch (this.algorithm) {
                    case 'bubble':
                        this.bubbleSort(array);
                        break;
                    case 'insertion':
                        this.insertionSort(array);
                        break;
                    case 'selection':
                        this.selectionSort(array);
                        break;
                    case 'quick':
                        this.quickSort(array, 0, array.length - 1);
                        break;
                    case 'merge':
                        this.mergeSort(array, 0, array.length - 1);
                        break;
                }
                
                // Ensure auxiliary arrays are padded to match the final arrays length
                this.padAuxiliaryArrays();

                // Visualize all recorded steps
                this.visualizeAlgorithmSteps();
            },

            bubbleSort(array) {
                const n = array.length;
                let swapped;
                let stepCounter = this.arrays.length - 1; // Start from the last recorded state index
                
                do {
                    swapped = false;
                    for (let i = 0; i < n - 1; i++) {
                        // Record comparison for the *next* potential state
                        this.comparisons[stepCounter] = [i, i + 1];
                        this.movements[stepCounter] = null; // Assume no movement initially for this step
                        
                        if (array[i] > array[i + 1]) {
                            // Record movement for this step
                            this.movements[stepCounter] = [i, i + 1]; 
                            
                            // Swap elements
                            [array[i], array[i + 1]] = [array[i + 1], array[i]];
                            swapped = true;
                            
                            // Record array state *after* swap
                            this.arrays.push([...array]);
                            stepCounter++; // Increment step counter only after recording a new array state
                        } else {
                             // If no swap, still record the state to visualize the comparison step
                             // Ensure comparison/movement arrays are extended if needed
                             this.comparisons[stepCounter] = [i, i + 1]; 
                             this.movements[stepCounter] = null;
                             this.arrays.push([...array]);
                             stepCounter++;
                        }
                    }
                    // Optimization: reduce loop range if needed (can complicate index tracking)
                    // n--; 
                } while (swapped);
                // Ensure comparisons/movements arrays are padded to match arrays length if needed
                 while (this.comparisons.length < this.arrays.length) this.comparisons.push(null);
                 while (this.movements.length < this.arrays.length) this.movements.push(null);
            },
            
            insertionSort(array) {
                const n = array.length;
                
                let stepCounter = this.arrays.length - 1; // Start from the last recorded state index
                
                for (let i = 1; i < n; i++) {
                    let key = array[i];
                    let j = i - 1;
                    let current_comparison_idx = i; // Index being compared/inserted

                    // State before starting insertion for 'key' already exists (arrays[stepCounter])
                    // Record initial comparison target (key vs element at j)
                    this.comparisons[stepCounter] = (j >= 0) ? [j, current_comparison_idx] : null;
                    this.movements[stepCounter] = null;

                    while (j >= 0 && array[j] > key) {
                         // Record comparison for the *next* state
                         this.comparisons[stepCounter] = [j, current_comparison_idx];
                         // Record movement (shift) for the *next* state
                         this.movements[stepCounter] = [j + 1, j]; // Element at j moves to j+1
                            
                         array[j + 1] = array[j];
                         current_comparison_idx = j + 1; // Update index of the 'hole'
                         j--;
                            
                         // Record array state after shift
                         this.arrays.push([...array]);
                         stepCounter++;
                         
                         // Record comparison for the *next* potential state (if loop continues)
                         this.comparisons[stepCounter] = (j >= 0) ? [j, current_comparison_idx] : null;
                         this.movements[stepCounter] = null; // Reset movement for next comparison
                    }
                    
                    // Place the key in its correct position
                    if (array[j + 1] !== key) {
                         // Record movement (final placement of key) for the *next* state
                         // We need a state to show the final placement
                         this.comparisons[stepCounter] = null; 
                         // Movement is placing 'key' into j+1. Source is conceptual (original index i).
                         this.movements[stepCounter] = [j + 1, i]; 
                         
                         array[j + 1] = key;
                         
                         // Record final array state after insertion
                         this.arrays.push([...array]);
                         stepCounter++;
                    } else {
                         // Key was already in place or loop didn't run, but we might need a state
                         // if the last comparison state wasn't recorded explicitly.
                         // Ensure the state after the inner loop is recorded if different.
                         if (!_.isEqual(this.arrays[stepCounter], array)) {
                             this.comparisons[stepCounter] = null; // No comparison/movement for this state
                             this.movements[stepCounter] = null;
                             this.arrays.push([...array]);
                             stepCounter++;
                         }
                    }
                }
                 // Ensure comparisons/movements arrays are padded
                 while (this.comparisons.length < this.arrays.length) this.comparisons.push(null);
                 while (this.movements.length < this.arrays.length) this.movements.push(null);
            },
            
            selectionSort(array) {
                const n = array.length;
                
                let stepCounter = this.arrays.length - 1; // Start from the last recorded state index

                for (let i = 0; i < n - 1; i++) {
                    let minIdx = i;
                    
                    // State before starting scan for pass 'i' already exists (arrays[stepCounter])
                    // Record initial comparison for the *next* state
                    this.comparisons[stepCounter] = (i + 1 < n) ? [minIdx, i + 1] : null;
                    this.movements[stepCounter] = null;

                    for (let j = i + 1; j < n; j++) {
                        // Record comparison for the *next* state
                        this.comparisons[stepCounter] = [minIdx, j];
                        this.movements[stepCounter] = null; // No movement during comparison scan
                        
                        // Record array state for each comparison step
                        this.arrays.push([...array]); 
                        stepCounter++;

                        if (array[j] < array[minIdx]) {
                            minIdx = j;
                            // Update comparison target for the *next* step if minIdx changed
                            this.comparisons[stepCounter] = (j + 1 < n) ? [minIdx, j + 1] : null;
                        } else {
                             // Set comparison for the *next* step
                             this.comparisons[stepCounter] = (j + 1 < n) ? [minIdx, j + 1] : null;
                        }
                         this.movements[stepCounter] = null; // Ensure movement is null for next comparison state
                    }
                    
                    // After finding the minimum, record the swap if needed
                    if (minIdx !== i) {
                        // Record movement (swap) for the *next* state
                        this.comparisons[stepCounter] = null; // No comparison during swap
                        this.movements[stepCounter] = [i, minIdx];
                        
                        // Swap elements
                        [array[i], array[minIdx]] = [array[minIdx], array[i]];
                        
                        // Record array state *after* swap
                        this.arrays.push([...array]);
                        stepCounter++;
                    } else {
                        // If no swap needed, ensure the state marking the end of the pass is present
                        // if it's different from the last comparison state.
                         if (!_.isEqual(this.arrays[stepCounter], array)) {
                             this.comparisons[stepCounter] = null;
                             this.movements[stepCounter] = null;
                             this.arrays.push([...array]);
                             stepCounter++;
                         }
                    }
                     // Ensure comparison/movement for the state *after* the potential swap/end-of-pass is nullified
                     this.comparisons[stepCounter] = null;
                     this.movements[stepCounter] = null;
                }
                 // Ensure comparisons/movements arrays are padded
                 while (this.comparisons.length < this.arrays.length) this.comparisons.push(null);
                 while (this.movements.length < this.arrays.length) this.movements.push(null);
            },
            
            quickSort(array, low, high) {
                if (low < high) {
                    const pivotIndex = this.partition(array, low, high);
                    
                    this.quickSort(array, low, pivotIndex - 1);
                    this.quickSort(array, pivotIndex + 1, high);
                }
            },
            
            partition(array, low, high) {
                const pivot = array[high];
                let i = low - 1;
                let stepCounter = this.arrays.length - 1; // Start from the last recorded state index
                
                // State before partition loop exists (arrays[stepCounter])
                // Record initial comparison for the *next* state
                this.comparisons[stepCounter] = (low < high) ? [low, high] : null;
                this.movements[stepCounter] = null;

                for (let j = low; j < high; j++) {
                    // Record comparison with pivot for the *next* state
                    this.comparisons[stepCounter] = [j, high];
                    this.movements[stepCounter] = null; // No movement yet for comparison step
                    
                    // Record state showing the comparison
                    this.arrays.push([...array]); 
                    stepCounter++;

                    if (array[j] < pivot) {
                        i++;
                        
                        // Check if swap is necessary (i !== j)
                        if (i !== j) {
                            // Record movement (swap) for the *next* state
                            this.comparisons[stepCounter] = null; // No comparison during swap
                            this.movements[stepCounter] = [i, j];
                            
                            // Swap elements
                            [array[i], array[j]] = [array[j], array[i]];
                            
                            // Record array state *after* swap
                            this.arrays.push([...array]);
                            stepCounter++;
                        }
                        // If i === j, no actual swap occurs, no new state needed just for that.
                    }
                     // Record comparison for the *next* iteration (if j+1 < high)
                     this.comparisons[stepCounter] = (j + 1 < high) ? [j + 1, high] : null;
                     this.movements[stepCounter] = null; // Reset movement for next comparison
                }
                
                // Move pivot to its final position (swap with element at i + 1)
                // Check if swap is necessary (i + 1 !== high)
                if (i + 1 !== high) {
                     // Record movement (pivot swap) for the *next* state
                    this.comparisons[stepCounter] = null;
                    this.movements[stepCounter] = [i + 1, high];

                    // Swap elements
                    [array[i + 1], array[high]] = [array[high], array[i + 1]];
                    
                    // Record array state *after* pivot swap
                    this.arrays.push([...array]);
                    stepCounter++;
                } else {
                     // If pivot is already in place, ensure state exists if different
                     if (!_.isEqual(this.arrays[stepCounter], array)) {
                         this.comparisons[stepCounter] = null;
                         this.movements[stepCounter] = null;
                         this.arrays.push([...array]);
                         stepCounter++;
                     }
                }
                 // Nullify comparison/movement for the state *after* partition finishes
                 this.comparisons[stepCounter] = null;
                 this.movements[stepCounter] = null;
                 // Padding handled by caller (quickSort/mergeSort)
                
                return i + 1;
            },
            
            mergeSort(array, left, right) {
                if (left < right) {
                    const mid = Math.floor((left + right) / 2);
                    
                    this.mergeSort(array, left, mid);
                    this.mergeSort(array, mid + 1, right);
                    
                    this.merge(array, left, mid, right);
                }
            },
            
            merge(array, left, mid, right) {
                const n1 = mid - left + 1;
                const n2 = right - mid;
                
                // Create temp arrays
                const L = new Array(n1);
                const R = new Array(n2);
                
                // Copy data to temp arrays
                for (let i = 0; i < n1; i++) {
                    L[i] = array[left + i];
                }
                for (let j = 0; j < n2; j++) {
                    R[j] = array[mid + 1 + j];
                }
                
                // Merge temp arrays back into array[left..right]
                // Use different variable names for the merge loop indices
                let idxL = 0; // index for L
                let idxR = 0; // index for R
                let k = left; // index for merged array
                let stepCounter = this.arrays.length - 1; // Start from the last recorded state index

                // State before merge loop exists (arrays[stepCounter])
                // Record initial comparison for the *next* state
                this.comparisons[stepCounter] = (idxL < n1 && idxR < n2) ? [left + idxL, mid + 1 + idxR] : null;
                this.movements[stepCounter] = null;
                
                while (idxL < n1 && idxR < n2) {
                    // Record comparison for the *next* state
                    this.comparisons[stepCounter] = [left + idxL, mid + 1 + idxR];
                    this.movements[stepCounter] = null; // No movement yet for comparison step
                    
                    // Record state showing the comparison
                    this.arrays.push([...array]); 
                    stepCounter++;

                    if (L[idxL] <= R[idxR]) {
                        // Check if a move/write is actually happening
                        if (array[k] !== L[idxL]) {
                            // Record movement (write from L) for the *next* state
                            this.comparisons[stepCounter] = null; 
                            this.movements[stepCounter] = [k, left + idxL]; // Target k, Source (conceptual) left+idxL
                            
                            array[k] = L[idxL];
                            
                            // Record array state *after* write
                            this.arrays.push([...array]);
                            stepCounter++;
                        }
                        idxL++;
                    } else {
                         // Check if a move/write is actually happening
                        if (array[k] !== R[idxR]) {
                            // Record movement (write from R) for the *next* state
                            this.comparisons[stepCounter] = null;
                            this.movements[stepCounter] = [k, mid + 1 + idxR]; // Target k, Source (conceptual) mid+1+idxR
                            
                            array[k] = R[idxR];
                            
                            // Record array state *after* write
                            this.arrays.push([...array]);
                            stepCounter++;
                        }
                        idxR++;
                    }
                    k++;
                     // Record comparison for the *next* iteration (if loop continues)
                     this.comparisons[stepCounter] = (idxL < n1 && idxR < n2) ? [left + idxL, mid + 1 + idxR] : null;
                     this.movements[stepCounter] = null; // Reset movement
                }
                
                // Copy remaining elements of L[] if any
                while (idxL < n1) {
                     // Check if a move/write is actually happening
                    if (array[k] !== L[idxL]) {
                        // Record movement for the *next* state
                        this.comparisons[stepCounter] = null;
                        this.movements[stepCounter] = [k, left + idxL];
                        
                        array[k] = L[idxL];
                        
                        // Record array state after change
                        this.arrays.push([...array]);
                        stepCounter++;
                    }
                    idxL++;
                    k++;
                     // Nullify comparison/movement for next state within this loop
                     this.comparisons[stepCounter] = null;
                     this.movements[stepCounter] = null;
                }
                
                // Copy remaining elements of R[] if any
                while (idxR < n2) {
                     // Check if a move/write is actually happening
                    if (array[k] !== R[idxR]) {
                        // Record movement for the *next* state
                        this.comparisons[stepCounter] = null;
                        this.movements[stepCounter] = [k, mid + 1 + idxR];
                        
                        array[k] = R[idxR];
                        
                        // Record array state after change
                        this.arrays.push([...array]);
                        stepCounter++;
                    }
                    idxR++;
                    k++;
                     // Nullify comparison/movement for next state within this loop
                     this.comparisons[stepCounter] = null;
                     this.movements[stepCounter] = null;
                }
                 // Ensure comparisons/movements arrays are padded by caller (mergeSort)
            },
            
            // Pad arrays after main sort call finishes
            padAuxiliaryArrays() {
                 while (this.comparisons.length < this.arrays.length) this.comparisons.push(null);
                 while (this.movements.length < this.arrays.length) this.movements.push(null);
            },

            visualizeAlgorithmSteps() {
                // Clear existing visualization
                this.clearVisualization();
                
                // Only create visualization for initial array at first
                this.createArrayBars(this.arrays[0], 0);
                
                // Reset current step
                this.currentStep = 0;
                
                // Update comparisons and movements for current step
                this.updateVisualization();
            },
            
            // Called from animation loop when animating
            advanceStep() {
                if (this.currentStep < this.arrays.length - 1) {
                    this.currentStep++;
                    
                    // Create visualization for this step only if it doesn't exist yet
                    const stepZ = -this.currentStep * 5;
                    const existingGroup = this.scene.children.find(c => 
                        c.type === 'Group' && Math.abs(c.position.z - stepZ) < 0.1);
                    
                    if (!existingGroup) {
                        this.createArrayBars(this.arrays[this.currentStep], this.currentStep);
                    }
                    
                    this.updateVisualization();
                } else {
                    // Animation complete
                    this.isAnimating = false;
                }
            },
            
            // Clears only transient visuals like lines and trails
            clearTransientVisuals() {
                 this.comparisonLines.forEach(line => {
                    if (line.geometry) line.geometry.dispose();
                    if (line.material) line.material.dispose();
                    this.scene.remove(line);
                });
                this.movementTrails.forEach(line => {
                    if (line.geometry) line.geometry.dispose();
                    if (line.material) line.material.dispose();
                    this.scene.remove(line);
                });
                this.comparisonLines = [];
                this.movementTrails = [];
            },

            // Updates colors, adds/removes lines/trails for the CURRENT step
            updateVisualization() {
                // --- 1. Update Bar Colors (Fading) ---
                const fadeDuration = 15; // How many steps it takes to fade significantly
                this.scene.children.forEach(child => {
                    if (child.type === 'Group') { // Iterate through step groups
                        // Only process the group for the current step for active highlighting/fading logic
                        const groupStep = Math.round(Math.abs(child.position.z / 5));
                        // if (groupStep <= this.currentStep) { // Process current and past steps for fading
                            child.children.forEach(bar => {
                                if (bar.userData && bar.userData.type === 'arrayBar' && bar.userData.lastMoved !== undefined) {
                                    const lastMoved = bar.userData.lastMoved;
                                    
                                    if (lastMoved === this.currentStep) {
                                         // Highlight bar moved in the *current* step
                                         const highlightLightness = 0.9;
                                         bar.material.color.setHSL(bar.userData.baseColor.getHSL({h:0,s:0,l:0}).h, 1.0, highlightLightness);
                                         bar.material.emissive.copy(bar.material.color).multiplyScalar(0.4);
                                    } else if (lastMoved !== -1 && lastMoved < this.currentStep) {
                                        // Fade bars moved in *previous* steps
                                        const stepsSinceMove = this.currentStep - lastMoved;
                                        const fadeFactor = Math.max(0, 1 - (stepsSinceMove / fadeDuration));
                                        
                                        // Interpolate lightness between highlight and base
                                        const highlightLightness = 0.9; 
                                        const baseLightness = bar.userData.baseColor.getHSL({ h: 0, s: 0, l: 0 }).l;
                                        const currentLightness = baseLightness + (highlightLightness - baseLightness) * fadeFactor;

                                        bar.material.color.setHSL(
                                            bar.userData.baseColor.getHSL({ h: 0, s: 0, l: 0 }).h,
                                            1.0, 
                                            currentLightness
                                        );
                                         // Also fade emissive intensity
                                         const highlightIntensity = 1.0; // Highlight glow intensity
                                         const baseIntensity = bar.userData.baseEmissiveIntensity;
                                         const currentIntensity = baseIntensity + (highlightIntensity - baseIntensity) * fadeFactor;
                                         bar.material.emissiveIntensity = currentIntensity;
                                         // Keep emissive color matching base color hue during fade
                                         bar.material.emissive.setHSL(bar.userData.baseEmissive.getHSL({h:0,s:0,l:0}).h, 1.0, currentLightness * 0.8); // Emissive slightly darker?

                                    } else { // lastMoved === -1 or > this.currentStep (e.g., during reset)
                                         // Reset to base color and emissive properties if not currently faded/highlighted
                                         if (!bar.material.color.equals(bar.userData.baseColor) || bar.material.emissiveIntensity !== bar.userData.baseEmissiveIntensity) {
                                             bar.material.color.copy(bar.userData.baseColor);
                                             bar.material.emissive.copy(bar.userData.baseEmissive);
                                             bar.material.emissiveIntensity = bar.userData.baseEmissiveIntensity;
                                         }
                                    }
                                } else if (bar.userData && bar.userData.type === 'arrayBar') {
                                     // Ensure bars that were never moved are reset (e.g., after reset)
                                     if (!bar.material.color.equals(bar.userData.baseColor) || bar.material.emissiveIntensity !== bar.userData.baseEmissiveIntensity) {
                                         bar.material.color.copy(bar.userData.baseColor);
                                         bar.material.emissive.copy(bar.userData.baseEmissive);
                                         bar.material.emissiveIntensity = bar.userData.baseEmissiveIntensity;
                                     }
                                }
                            });
                        // }
                    }
                });

                // --- 2. Clear Previous Transient Visuals ---
                this.clearTransientVisuals();
                
                // --- 3. Get Bars for the Current Step ---
                const currentStepZ = -this.currentStep * 5;
                const currentStepGroup = this.scene.children.find(child => 
                    child.type === 'Group' && Math.abs(child.position.z - currentStepZ) < 0.1);
                
                if (!currentStepGroup) return; // No bars for this step yet
                
                // Get bars, ensuring they are sorted by originalIndex for reliable lookup
                const bars = currentStepGroup.children
                                .filter(c => c.userData.type === 'arrayBar')
                                .sort((a, b) => a.userData.originalIndex - b.userData.originalIndex);
                 if (bars.length === 0) return;

                // --- 4. Show Comparisons for Current Step ---
                const comparison = this.comparisons[this.currentStep];
                if (this.showComparisons && comparison) {
                    // Indices in 'comparison' refer to the state *before* this step potentially changed it.
                    // We need to find the bars based on their values or track their current positions.
                    // Simplification: Assume 'comparison' indices still map correctly to the bars array *for visualization*.
                    // This might be inaccurate for sorts that drastically reorder within a step (like partition).
                    this.visualizeComparison(bars, comparison, currentStepZ);
                }
                
                // --- 5. Show Movements & Highlight for Current Step ---
                const movement = this.movements[this.currentStep];
                if (movement) { 
                    // Indices in 'movement' refer to the state *before* this step.
                    // Similar to comparisons, assume indices map correctly for visualization.
                    this.visualizeMovement(bars, movement, currentStepZ, this.showMovement);
                }
            },

            visualizeComparison(bars, comparison, stepZ) {
                const [idx1, idx2] = comparison;
                
                // Find bars based on the indices. Need robust way if indices change mid-step.
                // Using the sorted 'bars' array based on originalIndex is a common approach.
                if (idx1 >= 0 && idx1 < bars.length && idx2 >= 0 && idx2 < bars.length) {
                    // Find the actual bar objects corresponding to these indices in the *current* group
                    const bar1 = bars.find(b => b.userData.currentIndex === idx1); // Or use originalIndex if mapping is stable
                    const bar2 = bars.find(b => b.userData.currentIndex === idx2); // Or use originalIndex

                    // Fallback if currentIndex wasn't updated reliably (use direct index access)
                    const bar1Fallback = bars[idx1];
                    const bar2Fallback = bars[idx2];
                    
                    const finalBar1 = bar1 || bar1Fallback;
                    const finalBar2 = bar2 || bar2Fallback;

                    if (!finalBar1 || !finalBar2) {
                         console.warn("Comparison bars not found for indices:", idx1, idx2, "at step", this.currentStep);
                         return; 
                    }

                    // Use world position for accuracy, converting bar local pos to world pos
                    const bar1Pos = new THREE.Vector3();
                    finalBar1.getWorldPosition(bar1Pos); 
                    bar1Pos.y += finalBar1.geometry.parameters.height / 2; // Adjust to top center

                    const bar2Pos = new THREE.Vector3();
                    finalBar2.getWorldPosition(bar2Pos);
                    bar2Pos.y += finalBar2.geometry.parameters.height / 2; // Adjust to top center
                    
                    // Control point for the curve - higher up and between the bars
                    const controlPoint = new THREE.Vector3(
                        (bar1Pos.x + bar2Pos.x) / 2, 
                        Math.max(bar1Pos.y, bar2Pos.y) + 10 + Math.abs(bar1Pos.x - bar2Pos.x) * 0.2, // Height adjusts with distance
                        stepZ // Keep curve in the Z plane of the current step
                    );
                    
                    // Adjust bar positions to be relative to the scene origin if needed, or ensure curve uses world coords
                    // Since we used getWorldPosition, bar1Pos/bar2Pos are world coords. Control point needs correct Z.
                    
                    const curve = new THREE.QuadraticBezierCurve3(bar1Pos, controlPoint, bar2Pos);
                    
                    const points = curve.getPoints(20);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const material = new THREE.LineBasicMaterial({ 
                        color: 0xffff00, // Yellow
                        linewidth: 2,    // Note: linewidth > 1 may not work on all systems/drivers
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const line = new THREE.Line(geometry, material);
                    line.userData = { type: 'comparisonLine' }; // Tag for easy removal
                    
                    this.scene.add(line);
                    this.comparisonLines.push(line); // Store reference
                } else {
                     console.warn("Invalid comparison indices:", idx1, idx2, "at step", this.currentStep);
                }
            },
            
            visualizeMovement(bars, movement, stepZ, showTrail) {
                const [idx1, idx2] = movement; // Often [targetIdx, sourceIdx] or [idxA, idxB] for swap
                
                // Find bars involved in the movement using indices from the *previous* state.
                 if (idx1 >= 0 && idx1 < bars.length && idx2 >= 0 && idx2 < bars.length) {
                    // Find the actual bar objects corresponding to these indices
                    const bar1 = bars.find(b => b.userData.currentIndex === idx1); // Or originalIndex
                    const bar2 = bars.find(b => b.userData.currentIndex === idx2); // Or originalIndex

                    // Fallback
                    const bar1Fallback = bars[idx1];
                    const bar2Fallback = bars[idx2];

                    const finalBar1 = bar1 || bar1Fallback;
                    const finalBar2 = bar2 || bar2Fallback; // May represent the same bar if it's a shift vs swap

                    if (!finalBar1) { // We at least need the target bar
                         console.warn("Movement bar not found for index:", idx1, "at step", this.currentStep);
                         return;
                    }

                    // --- Mark Moved Bars for Highlighting/Fading ---
                    // Set the step marker. The actual color/intensity change happens in updateVisualization's loop.
                    finalBar1.userData.lastMoved = this.currentStep;
                     // Only mark bar2 if it's different from bar1 (swap vs shift/write)
                    if (finalBar2 && finalBar1 !== finalBar2) { 
                        finalBar2.userData.lastMoved = this.currentStep;
                    }
                    // Force an immediate visual update for the highlighted bars in this step
                    const highlightLightness = 0.9;
                    const highlightIntensity = 1.0;
                    finalBar1.material.color.setHSL(finalBar1.userData.baseColor.getHSL({h:0,s:0,l:0}).h, 1.0, highlightLightness);
                    finalBar1.material.emissive.copy(finalBar1.material.color); // Emissive matches bright color
                    finalBar1.material.emissiveIntensity = highlightIntensity;
                    if (finalBar2 && finalBar1 !== finalBar2) {
                        finalBar2.material.color.setHSL(finalBar2.userData.baseColor.getHSL({h:0,s:0,l:0}).h, 1.0, highlightLightness);
                        finalBar2.material.emissive.copy(finalBar2.material.color);
                        finalBar2.material.emissiveIntensity = highlightIntensity;
                    }


                    // --- Draw Movement Trail (if enabled) ---
                    if (showTrail && finalBar1 && finalBar2 && finalBar1 !== finalBar2) { // Only draw trail for actual swaps/moves between different positions
                         const bar1Pos = new THREE.Vector3();
                         finalBar1.getWorldPosition(bar1Pos);
                         // Use base of bar for movement trail start/end? Or center? Let's use center y.
                         // bar1Pos.y += 0; 

                         const bar2Pos = new THREE.Vector3();
                         finalBar2.getWorldPosition(bar2Pos);
                         // bar2Pos.y += 0;

                        // Control point for the curve - lower down for movement?
                        const controlPoint = new THREE.Vector3(
                            (bar1Pos.x + bar2Pos.x) / 2, 
                            Math.min(bar1Pos.y, bar2Pos.y) - 5 - Math.abs(bar1Pos.x - bar2Pos.x) * 0.1, // Lower curve
                            stepZ // Keep curve in the Z plane
                        );

                        const curve = new THREE.QuadraticBezierCurve3(bar1Pos, controlPoint, bar2Pos);
                        
                        const points = curve.getPoints(20);
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        
                        const material = new THREE.LineBasicMaterial({
                            color: 0x00ffff, // Bright Cyan
                            linewidth: 3,    // Increased width (may not render thicker on all systems)
                            transparent: false, // Make it solid
                            opacity: 0.9      // Slightly less than fully opaque if needed
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        line.userData = { type: 'movementTrail' }; // Tag for removal
                        
                        this.scene.add(line);
                        this.movementTrails.push(line); // Store reference
                    }
                } else {
                     console.warn("Invalid movement indices:", idx1, idx2, "at step", this.currentStep);
                }
            },
            
            // Main animation loop
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.stats.begin();
                
                // Update controls (needed for damping and potentially updates lookAt)
                this.controls.update(); 

                // --- Camera Auto-Movement ---
                // Only move camera automatically if not currently interacting 
                // and animation has generated steps.
                if (!this.isUserInteracting && this.arrays.length > 1) {
                    // Smoothly interpolate camera position and target towards the calculated target
                    // Use a small threshold to stop lerping when close enough
                    const positionThreshold = 0.05;
                    const targetThreshold = 0.05;
                    const lerpFactor = 0.04; // Adjust lerp factor for speed

                    if (this.camera.position.distanceTo(this.cameraTarget.position) > positionThreshold) {
                        this.camera.position.lerp(this.cameraTarget.position, lerpFactor);
                    } else {
                        // Snap to final position if very close
                        this.camera.position.copy(this.cameraTarget.position);
                    }

                    if (this.controls.target.distanceTo(this.cameraTarget.lookAt) > targetThreshold) {
                         this.controls.target.lerp(this.cameraTarget.lookAt, lerpFactor);
                         // controls.update() should handle calling camera.lookAt(controls.target)
                    } else {
                         // Snap to final target if very close
                         this.controls.target.copy(this.cameraTarget.lookAt);
                    }
                    // Ensure controls.update() is called AFTER lerping target
                    // this.controls.update(); // Already called at the start of animate loop
                } else if (this.isUserInteracting) {
                     // If user is interacting, update the *target* state to match the *current* camera state.
                     // This effectively pauses the auto-camera by making its target the current user position.
                     this.cameraTarget.position.copy(this.camera.position);
                     this.cameraTarget.lookAt.copy(this.controls.target);
                }
                
                // --- Algorithm Step Advancement ---
                if (this.isAnimating) {
                    // Calculate delay based on animation speed (higher speed = lower delay)
                    const delayFactor = Math.max(1, 60 / this.animationSpeed); // Target frames per step
                    if (this.frame % Math.round(delayFactor) === 0) {
                        const oldStep = this.currentStep;
                        this.advanceStep(); // This increments currentStep and updates visualization
                        
                        // --- Update Camera Target ---
                        // Update target only if the step actually changed and we are not interacting
                        if (oldStep !== this.currentStep && !this.isUserInteracting) {
                            // Calculate target Z based on current step, looking slightly ahead
                            const lookAheadSteps = Math.min(10, Math.max(3, Math.floor(this.dataSize * 0.2))); // Look ahead based on size
                            const targetStepZ = -(this.currentStep + lookAheadSteps) * 5;
                            const currentStepZ = -this.currentStep * 5;

                            // Adjust distance and height based on data size for better framing
                            const cameraDistance = 60 + this.dataSize * 1.8; 
                            const cameraHeight = 80 + this.dataSize * 0.8; 

                            // Set the target lookAt point (where the camera should point)
                            // Look towards the Z depth between current and upcoming steps
                            this.cameraTarget.lookAt.set(
                                0, // Look towards center X
                                0, // Look towards base Y
                                (currentStepZ + targetStepZ) / 2 // Look at midpoint Z
                            ); 

                            // Set the target position (where the camera should move to)
                            // Maintain a similar viewing angle relative to the lookAt point
                            // Calculate offset based on current camera angle or a fixed overhead angle
                            const offset = new THREE.Vector3();
                            offset.copy(this.camera.position).sub(this.controls.target); // Get current offset
                            offset.normalize().multiplyScalar(cameraDistance); // Scale offset to desired distance

                            // Position camera *ahead* of the lookAt point (further negative Z)
                            this.cameraTarget.position.set(
                                0, // Center X
                                cameraHeight * 0.8, // Slightly lower angle than directly overhead
                                this.cameraTarget.lookAt.z - cameraDistance * 0.9 // Position AHEAD (more negative Z)
                            ); 
                            
                            // Alternative: Maintain current horizontal angle but position ahead
                            // let currentAngle = Math.atan2(this.camera.position.x - this.controls.target.x, this.camera.position.z - this.controls.target.z);
                            // this.cameraTarget.position.set(
                            //     this.cameraTarget.lookAt.x + Math.sin(currentAngle) * cameraDistance * 0.8, 
                            //     cameraHeight, 
                            //     this.cameraTarget.lookAt.z + Math.cos(currentAngle) * cameraDistance * 0.8
                            // ); 

                        }
                    }
                    this.frame++;
                }
                
                // Render scene
                this.renderer.render(this.scene, this.camera);
                
                this.stats.end();
            },
            
            // Reset the visualization
            reset() {
                this.isAnimating = false;
                this.isUserInteracting = false; // Reset interaction flag
                this.currentStep = 0;
                this.frame = 0;
                
                // Clear existing visualization
                this.clearVisualization();
                
                // Reset arrays and tracking data
                this.arrays = [];
                this.comparisons = [];
                this.movements = [];
                this.algorithmSteps = [];
                
                // Generate new data
                this.generateData();
                
                // Reset camera target to initial 'ahead' view
                const initialCamPos = new THREE.Vector3(0, 80, -50);
                const initialLookAt = new THREE.Vector3(0, 0, -70);
                this.cameraTarget.position.copy(initialCamPos);
                this.cameraTarget.lookAt.copy(initialLookAt);
                
                // Force immediate camera reset without interpolation
                this.camera.position.copy(this.cameraTarget.position);
                this.camera.lookAt(this.cameraTarget.lookAt);
                this.controls.target.copy(this.cameraTarget.lookAt);
                this.controls.update();
            },
            
            frame: 0
        };
        
        // Initialize the application
        window.addEventListener('load', () => {
            app.init();
        });
    </script>
</body>
</html>
